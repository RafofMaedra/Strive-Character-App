<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Strive Character Creator</title>
<style>
  :root{
    --bg:#0f1115;
    --panel:#171a21;
    --panel2:#11141a;
    --text:#e9eef7;
    --muted:#a9b4c3;
    --border:rgba(255,255,255,.12);
    --border2:rgba(255,255,255,.18);
    --accent:#e2c36a;
    --accent2:#70a7ff;
    --danger:#ff5c5c;
    --ok:#5cffb2;
    --shadow: 0 14px 35px rgba(0,0,0,.35);
    --r:16px;
    --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
  *{ box-sizing:border-box; }
  html,body{ height:100%; }
  body{
    margin:0;
    font-family:var(--sans);
    background:
      radial-gradient(1000px 600px at 20% 0%, rgba(226,195,106,.10), transparent 60%),
      radial-gradient(900px 700px at 95% 10%, rgba(112,167,255,.10), transparent 60%),
      var(--bg);
    color:var(--text);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  /* Top bar (NOT sticky; scrolls away) */
  header{
    background: rgba(15,17,21,.92);
    border-bottom: 1px solid var(--border);
  }
  .topbar{
    max-width:1200px;
    margin:0 auto;
    padding:10px 14px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
  }
  .brand{
    display:flex;
    align-items:baseline;
    gap:10px;
    min-width:0;
  }
  .brand h1{
    margin:0;
    font-size:16px;
    font-weight:800;
    letter-spacing:.2px;
    white-space:nowrap;
  }
  .badge{
    font-size:12px;
    padding:3px 8px;
    border:1px solid var(--border);
    border-radius:999px;
    color:var(--muted);
    background:rgba(255,255,255,.03);
    white-space:nowrap;
  }
  .top-actions{
    display:flex;
    align-items:center;
    gap:8px;
    flex-wrap:wrap;
    justify-content:flex-end;
  }

  button, .btn, select{
    appearance:none;
    border:1px solid var(--border2);
    background: rgba(255,255,255,.04);
    color:var(--text);
    padding:8px 10px;
    border-radius:12px;
    cursor:pointer;
    font-weight:700;
    user-select:none;
    -webkit-tap-highlight-color: transparent;
  }
  button:hover, .btn:hover, select:hover{
    background: rgba(255,255,255,.07);
    border-color: rgba(255,255,255,.22);
  }
  button:active{ transform: translateY(1px); }
  button.primary{
    border-color: rgba(226,195,106,.45);
    background: rgba(226,195,106,.12);
  }
  button.primary:hover{
    background: rgba(226,195,106,.18);
    border-color: rgba(226,195,106,.65);
  }
  button.danger{
    border-color: rgba(255,92,92,.45);
    background: rgba(255,92,92,.12);
  }
  button:disabled{ opacity:.45; cursor:not-allowed; transform:none; }
  select{
    padding-right:34px;
    background-image:
      linear-gradient(45deg, transparent 50%, rgba(255,255,255,.75) 50%),
      linear-gradient(135deg, rgba(255,255,255,.75) 50%, transparent 50%);
    background-position:
      calc(100% - 16px) calc(50% - 3px),
      calc(100% - 11px) calc(50% - 3px);
    background-size:5px 5px, 5px 5px;
    background-repeat:no-repeat;
  }
  option{ color:#000; }

  /* Tabs */
  .wrap{ max-width:1200px; margin:0 auto; padding:14px; }
  .tabs{
    display:flex;
    gap:8px;
    margin:10px 0 14px;
    flex-wrap:wrap;
  }
  .tab{
    padding:8px 12px;
    border-radius:999px;
    border:1px solid var(--border);
    background: rgba(255,255,255,.03);
    color:var(--muted);
    cursor:pointer;
    font-weight:800;
  }
  .tab.active{
    color:var(--text);
    border-color: rgba(226,195,106,.55);
    background: rgba(226,195,106,.10);
  }

  /* Cards + fields */
  .grid{
    display:grid;
    grid-template-columns: 1.1fr .9fr;
    gap:12px;
    grid-template-areas:
      "vitals portrait"
      "core portrait"
      "skills portrait"
      "features details"
      "wealth details";
  }
  @media (max-width: 980px){
    /* Mobile order: vitals ABOVE portrait */
    .grid{
      grid-template-columns: 1fr;
      grid-template-areas:
        "vitals"
        "portrait"
        "core"
        "skills"
        "features"
        "details"
        "wealth";
    }
  }

  .card{
    background: linear-gradient(180deg, rgba(255,255,255,.035), rgba(255,255,255,.02));
    border:1px solid var(--border);
    border-radius: var(--r);
    box-shadow: var(--shadow);
    overflow:hidden;
  }
  .card .hd{
    padding:10px 12px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    border-bottom:1px solid var(--border);
    background: rgba(0,0,0,.18);
  }
  .card .hd .t{
    font-weight:900;
    letter-spacing:.2px;
  }
  .card .bd{ padding:12px; }

  .fields{
    display:grid;
    grid-template-columns: repeat(12, 1fr);
    gap:10px;
    align-items:end;
  }
  .field{ grid-column: span 6; min-width:0; }
  .span12{ grid-column: span 12; }
  .span8{ grid-column: span 8; }
  .span4{ grid-column: span 4; }
  .span3{ grid-column: span 3; }
  .span2{ grid-column: span 2; }

  @media (max-width: 520px){
    .field{ grid-column: span 12; }
    .span2,.span3,.span4,.span8{ grid-column: span 12; }
  }

  label{ display:block; font-size:12px; color:var(--muted); margin:0 0 4px 2px; }
  input, textarea{
    width:100%;
    border-radius:12px;
    border:1px solid var(--border);
    padding:10px 10px;
    background: rgba(255,255,255,.04);
    color:var(--text);
    outline:none;
    font: inherit;
  }
  input:focus, textarea:focus{
    border-color: rgba(226,195,106,.55);
    box-shadow: 0 0 0 3px rgba(226,195,106,.12);
  }
  textarea{ min-height: 120px; resize: vertical; }
  .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  .spacer{ flex:1; }

  .pill{
    display:inline-block;
    padding:3px 8px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.15);
    background: rgba(255,255,255,.03);
    font-size: 12px;
    color: var(--muted);
  }

  /* Vitals strip (not sticky) */
  .vitalsStrip{
    display:grid;
    grid-template-columns: repeat(6, minmax(0, 1fr));
    gap:10px;
  }
  @media (max-width: 980px){
    .vitalsStrip{ grid-template-columns: repeat(3, minmax(0, 1fr)); }
  }
  .vItem{
    padding:8px 10px;
    border:1px solid var(--border);
    border-radius:12px;
    background: rgba(0,0,0,.12);
    min-width:0;
  }
  .vLabel{ font-size:12px; opacity:.75; }
  .vValue{ font-weight:900; letter-spacing:.2px; margin-top:2px; }

  /* Quick +/- controls for current Grit/Focus */
  .vAdjust{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:8px;
  }
  .iconTiny{
    width:26px;
    height:26px;
    padding:0;
    border-radius:10px;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    font-weight:900;
  }

  /* Portrait stage: fixed aspect ratio, no squish */
  .portraitStage{
    position:relative;
    width:100%;
    aspect-ratio: 5 / 7; /* 2.5:3.5 */
    border-radius: 14px;
    overflow:hidden;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.18);
  }
  canvas#portraitCanvas{
    width:100%;
    height:100%;
    display:block;
    touch-action:none; /* enable custom pinch/pan */
  }
  #btnPortraitLock{
    position:absolute;
    top:10px;
    right:10px;
    width:38px;
    height:38px;
    padding:0;
    border-radius:999px;
    display:flex;
    align-items:center;
    justify-content:center;
    background: rgba(0,0,0,.50);
    border:1px solid rgba(255,255,255,.18);
    box-shadow: 0 6px 16px rgba(0,0,0,.35);
  }
  #btnPortraitLock.is-unlocked{
    background: rgba(226,195,106,.18);
    border-color: rgba(226,195,106,.45);
  }

  /* Skills list */
  .list{
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  .item{
    display:flex;
    gap:10px;
    align-items:center;
    padding:10px 10px;
    border:1px solid var(--border);
    border-radius: 12px;
    background: rgba(0,0,0,.10);
  }
  .item .name{
    font-weight:900;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  .item .meta{
    color:var(--muted);
    font-size:12px;
    margin-top:2px;
  }
  .item .left{
    min-width:0;
  }

  /* Details (accordion) */
  details{
    border:1px solid var(--border);
    border-radius: 14px;
    overflow:hidden;
    background: rgba(0,0,0,.08);
  }
  details summary{
    list-style:none;
    cursor:pointer;
    padding:10px 12px;
    font-weight:900;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    background: rgba(0,0,0,.18);
    border-bottom:1px solid var(--border);
  }
  details summary::-webkit-details-marker{ display:none; }
  details .inner{ padding:12px; }

  /* Modal */
  .modalBackdrop{
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,.62);
    display:none;
    align-items:center;
    justify-content:center;
    padding: 16px;
    z-index: 500;
  }
  /* PATCH: make in-app windows effectively opaque for readability */
  .modal{
    width:min(720px, 100%);
    max-height: min(92vh, 900px);
    overflow:auto;
    background: rgba(23,26,33,.98); /* was translucent gradient */
    border:1px solid rgba(255,255,255,.18);
    border-radius: 18px;
    box-shadow: 0 18px 60px rgba(0,0,0,.55);
  }
  .modal .mh{
    padding:12px 14px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    border-bottom:1px solid rgba(255,255,255,.14);
    background: rgba(17,20,26,.98);
  }
  .modal .mh .title{
    font-weight:950;
    letter-spacing:.2px;
  }
  .modal .mb{ padding:14px; }
  .modal .mf{
    padding:12px 14px;
    border-top:1px solid rgba(255,255,255,.14);
    background: rgba(17,20,26,.98);
    display:flex;
    gap:10px;
    justify-content:flex-end;
    flex-wrap:wrap;
  }
  .toast{
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
    bottom: 16px;
    padding: 10px 12px;
    border-radius: 14px;
    border: 1px solid var(--border);
    background: rgba(0,0,0,.70);
    backdrop-filter: blur(10px);
    color: var(--text);
    display:none;
    z-index: 800;
  }
  .toast.show{ display:block; }

  /* Topbar: mobile compact (title + New + Menu) */
  @media (max-width: 980px){
    .badge{ display:none; }
    .top-actions .desktopOnly{ display:none; }
    .top-actions{ flex-wrap:nowrap; }
    .brand h1{ font-size:15px; }
  }
  @media (min-width: 981px){
    .top-actions .mobileOnly{ display:none; }
  }
</style>
</head>
<body>

<header>
  <div class="topbar">
    <div class="brand">
      <h1>Strive Character Creator</h1>
      <span class="badge" id="savedBadge">Saved âœ“</span>
    </div>

    <div class="top-actions">
      <select id="newMenu" aria-label="New">
        <option value="">Newâ€¦</option>
        <option value="blank">New (Blank)</option>
        <option value="guided">New (Guided Creation)</option>
      </select>

      <button class="mobileOnly" id="btnMenu" title="Menu">â˜°</button>

      <button class="desktopOnly" id="btnOpen">Openâ€¦</button>
      <button class="desktopOnly primary" id="btnSave">Export JSON</button>
      <button class="desktopOnly" id="btnExportCards">Export Card PNGs</button>
      <button class="desktopOnly" id="btnLevelUp">Level Up</button>
      <button class="desktopOnly danger" id="btnClearAutosave" title="Clears this browser's autosave copy.">Clear Autosave</button>
    </div>
  </div>
</header>

<main class="wrap">
  <div class="tabs">
    <div class="tab active" data-tab="character">Character</div>
    <div class="tab" data-tab="details">Notes</div>
    <div class="tab" data-tab="about">About</div>
  </div>

  <!-- CHARACTER TAB -->
  <section id="tab-character">
    <div class="grid">

      <div class="card" style="grid-area:vitals" id="cardVitals">
        <div class="hd">
          <div class="t">Quick Stats</div>
          <span class="pill" id="autosavePill">Autosave: on</span>
        </div>
        <div class="bd">
          <div class="vitalsStrip">
            <div class="vItem">
              <div class="vLabel">Name</div>
              <div class="vValue" id="vName">â€”</div>
            </div>
            <div class="vItem">
              <div class="vLabel">Level</div>
              <div class="vValue" id="vLevel">1</div>
            </div>
            <div class="vItem">
              <div class="vLabel">Body / Mind</div>
              <div class="vValue" id="vStats">1 / 1</div>
            </div>

            <div class="vItem">
              <div class="vLabel">Grit</div>
              <div class="vAdjust">
                <button class="iconTiny" id="btnGritMinus" type="button" title="Grit -1">âˆ’</button>
                <div class="vValue" id="vGrit">4 / 4</div>
                <button class="iconTiny" id="btnGritPlus" type="button" title="Grit +1">+</button>
              </div>
            </div>

            <div class="vItem">
              <div class="vLabel">Focus</div>
              <div class="vAdjust">
                <button class="iconTiny" id="btnFocusMinus" type="button" title="Focus -1">âˆ’</button>
                <div class="vValue" id="vFocus">4 / 4</div>
                <button class="iconTiny" id="btnFocusPlus" type="button" title="Focus +1">+</button>
              </div>
            </div>

            <div class="vItem">
              <div class="vLabel">Strive Dice</div>
              <div class="vValue" id="vDice">0 / 0</div>
            </div>
          </div>
        </div>
      </div>

      <div class="card" style="grid-area:portrait" id="cardPortrait">
        <div class="hd">
          <div class="t">Portrait</div>
          <span class="pill" id="zoomPill">1.00Ã—</span>
        </div>
        <div class="bd">
          <div class="portraitStage" id="portraitStage">
            <canvas id="portraitCanvas" width="500" height="700"></canvas>
            <button id="btnPortraitLock" type="button" title="Toggle portrait lock">ðŸ”’</button>
          </div>

          <div class="fields" style="margin-top:12px;">
            <div class="field span12">
              <label for="portraitFile">Load image</label>
              <input id="portraitFile" type="file" accept="image/*" />
            </div>
            <div class="field span12">
              <label>Zoom</label>
              <div class="row">
                <input id="portraitZoom" type="range" min="0.5" max="3" step="0.01" value="1.00" style="flex:1;" />
                <button id="btnPortraitReset" type="button">Reset</button>
                <button class="danger" id="btnPortraitClear" type="button">Clear</button>
              </div>
            </div>
          </div>

        </div>
      </div>

      <div class="card" style="grid-area:core" id="cardCore">
        <div class="hd">
          <div class="t">Core</div>
          <span class="pill" id="kpiThreshold">Success Threshold: 3+</span>
        </div>
        <div class="bd">
          <div class="fields">
            <div class="field span8">
              <label for="name">Name</label>
              <input id="name" type="text" enterkeyhint="done" autocomplete="off" />
            </div>
            <div class="field span4">
              <label for="level">Level</label>
              <input id="level" type="number" min="1" max="12" step="1" />
            </div>

            <div class="field span6">
              <label for="species">Species</label>
              <input id="species" type="text" enterkeyhint="done" />
            </div>
            <div class="field span6">
              <label for="background">Background</label>
              <input id="background" type="text" enterkeyhint="done" />
            </div>

            <div class="field span3">
              <label for="body">Body</label>
              <input id="body" type="number" min="1" max="2" step="1" />
            </div>
            <div class="field span3">
              <label for="mind">Mind</label>
              <input id="mind" type="number" min="1" max="2" step="1" />
            </div>

            <div class="field span3">
              <label for="gritMax">Grit (max)</label>
              <input id="gritMax" type="number" min="0" step="1" />
            </div>
            <div class="field span3">
              <label for="gritCur">Grit (current)</label>
              <input id="gritCur" type="number" min="0" step="1" />
            </div>

            <div class="field span3">
              <label for="focusMax">Focus (max)</label>
              <input id="focusMax" type="number" min="0" step="1" />
            </div>
            <div class="field span3">
              <label for="focusCur">Focus (current)</label>
              <input id="focusCur" type="number" min="0" step="1" />
            </div>

            <div class="field span3">
              <label for="dpMax">Strive Dice (max)</label>
              <input id="dpMax" type="number" min="0" step="1" />
            </div>
            <div class="field span3">
              <label for="dpCur">Strive Dice (current)</label>
              <input id="dpCur" type="number" min="0" step="1" />
            </div>
          </div>
        </div>
      </div>

      <div class="card" style="grid-area:skills" id="cardSkills">
        <div class="hd">
          <div class="t">Skills</div>
          <div class="row">
            <button class="primary" id="btnAddSkill" type="button">Add</button>
          </div>
        </div>
        <div class="bd">
          <div class="list" id="skillsList"></div>
        </div>
      </div>

      <div class="card" style="grid-area:features" id="cardFeatures">
        <div class="hd">
          <div class="t">Features</div>
        </div>
        <div class="bd">
          <label for="features">One per line</label>
          <textarea id="features" class="mono" placeholder="â€¢ ..."></textarea>
        </div>
      </div>

      <div class="card" style="grid-area:details" id="cardDetails">
        <div class="hd">
          <div class="t">Character Details</div>
        </div>
        <div class="bd">
          <textarea id="details" placeholder="Gear, bonds, notes..."></textarea>
        </div>
      </div>

      <div class="card" style="grid-area:wealth" id="cardWealth">
        <div class="hd">
          <div class="t">Wealth</div>
        </div>
        <div class="bd">
          <div class="fields">
            <div class="field span4">
              <label for="wealthCoins">Coins</label>
              <input id="wealthCoins" type="number" min="0" step="1" />
            </div>
            <div class="field span8">
              <label for="wealthOther">Other</label>
              <textarea id="wealthOther" placeholder=""></textarea>
            </div>
          </div>
        </div>
      </div>

    </div>
  </section>

  <!-- NOTES TAB -->
  <section id="tab-details" style="display:none;">
    <div class="card">
      <div class="hd">
        <div class="t">Notes</div>
        <span class="pill">Freeform notes</span>
      </div>
      <div class="bd">
        <textarea id="detailsBig" placeholder="Extra notes..."></textarea>
      </div>
    </div>
  </section>

  <!-- ABOUT TAB -->
  <section id="tab-about" style="display:none;">
    <div class="card">
      <div class="hd"><div class="t">About</div></div>
      <div class="bd">
        <div style="line-height:1.5; color:var(--muted);">
          <p style="margin-top:0;">
            Skill tags:
            <b style="color:var(--text)">(B)</b> Broad,
            <b style="color:var(--text)">(N)</b> Narrow.
          </p>
          <p>
            Card Export creates two PNG files:
            <b style="color:var(--text)">CHARACTERNAME_F.png</b> and
            <b style="color:var(--text)">CHARACTERNAME_B.png</b>
            using a 2.5:3.5 layout and transparent rounded corners.
          </p>
          <p>
            Species traits (examples): Lowlight Vision, Underwater Adaptions, Heat Resistance.
          </p>
          <p>
            Level Up is guided by the rules. If you need homebrew/GM edge cases, just edit the sheet fields directly (Level, max pools, Strive Dice max, etc.).
          </p>
        </div>
      </div>
    </div>
  </section>

</main>

<input id="jsonFile" type="file" accept="application/json,.json" style="display:none;" />

<div class="modalBackdrop" id="modalBackdrop">
  <div class="modal" role="dialog" aria-modal="true" aria-label="Modal">
    <div class="mh">
      <div class="title" id="modalTitle">Menu</div>
      <button id="btnModalClose" type="button" title="Close">âœ•</button>
    </div>
    <div class="mb" id="modalBody"></div>
    <div class="mf" id="modalFooter"></div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const safeInt = (v, d=0) => {
    const n = parseInt(v, 10);
    return Number.isFinite(n) ? n : d;
  };
  const safeFloat = (v, d=0) => {
    const n = parseFloat(v);
    return Number.isFinite(n) ? n : d;
  };
  const now = () => Date.now();

  const STORAGE_KEY = "strive_character_creator_v4";
  const FONT_SERIF = '"Times New Roman", Times, serif';

  const EXPORT_CARD_W = 928;
  const EXPORT_CARD_H = 1312;

  // Adaptive text styling for name box based on character count
  function getAdaptiveTextStyle(text, baseFontSize) {
    const len = (text || "").length;

    // Letter spacing: 0 for â‰¤9 chars, decrease by 0.3px per char over 9
    const letterSpacing = len <= 9 ? 0 : -0.3 * (len - 9);

    // Font size: 100% for â‰¤9 chars, decrease by 3% per char over 9
    let fontSize = baseFontSize;
    if (len > 9) {
      const reduction = 0.03 * (len - 9);
      fontSize = baseFontSize * Math.max(0.56, 1 - reduction); // Floor at 56%
    }

    return { fontSize: Math.round(fontSize), letterSpacing };
  }

  const data = {
    name: "",
    level: 1,
    species: "",
    background: "",
    body: 1,
    mind: 1,
    grit_max: 4,
    grit_cur: 4,
    focus_max: 4,
    focus_cur: 4,
    dp_max: 0,
    dp_cur: 0,
    skills: [],
    features_text: "",
    details: "",
    wealth_coins: 0,
    wealth_other: "",
    mastery_skill: "",
    threat_assist_cost: null,
    advancement_log: { applied_levels: [] },
    portrait: {
      dataUrl: null,
      zoom: 1.0,
      offX: 0,
      offY: 0,
      locked: false
    }
  };

  let toastTimer = null;
  function toast(msg){
    const t = $("toast");
    t.textContent = msg;
    t.classList.add("show");
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>t.classList.remove("show"), 1400);
  }

  let lastSave = 0;
  function saveAutosave(){
    try{
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      lastSave = now();
      $("savedBadge").textContent = "Saved âœ“";
    }catch(e){
      $("savedBadge").textContent = "Save failed";
    }
  }
  function loadAutosave(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return false;
      const obj = JSON.parse(raw);
      if(!obj || typeof obj !== "object") return false;
      Object.assign(data, obj);
      if(obj.portrait) Object.assign(data.portrait, obj.portrait);
      return true;
    }catch(e){
      return false;
    }
  }
  function clearAutosave(){
    localStorage.removeItem(STORAGE_KEY);
    toast("Autosave cleared");
    $("savedBadge").textContent = "â€”";
  }

  function bindInputs(){
    const bind = (id, key, parser) => {
      const el = $(id);
      el.addEventListener("input", () => {
        data[key] = parser ? parser(el.value) : el.value;
        normaliseDerived();
        refreshAll();
        saveAutosave();
      });
    };

    bind("name", "name", (v)=>String(v||""));
    bind("level", "level", (v)=>clamp(safeInt(v,1), 1, 12));
    bind("species", "species", (v)=>String(v||""));
    bind("background", "background", (v)=>String(v||""));
    bind("body", "body", (v)=>clamp(safeInt(v,1), 1, 2));
    bind("mind", "mind", (v)=>clamp(safeInt(v,1), 1, 2));

    bind("gritMax", "grit_max", (v)=>Math.max(0, safeInt(v,0)));
    bind("gritCur", "grit_cur", (v)=>Math.max(0, safeInt(v,0)));
    bind("focusMax", "focus_max", (v)=>Math.max(0, safeInt(v,0)));
    bind("focusCur", "focus_cur", (v)=>Math.max(0, safeInt(v,0)));
    bind("dpMax", "dp_max", (v)=>Math.max(0, safeInt(v,0)));
    bind("dpCur", "dp_cur", (v)=>Math.max(0, safeInt(v,0)));

    bind("features", "features_text", (v)=>String(v||""));
    bind("details", "details", (v)=>String(v||""));
    bind("detailsBig", "details", (v)=>String(v||""));
    bind("wealthCoins", "wealth_coins", (v)=>Math.max(0, safeInt(v,0)));
    bind("wealthOther", "wealth_other", (v)=>String(v||""));

    $("btnGritMinus").addEventListener("click", ()=>{ data.grit_cur = clamp(data.grit_cur-1, 0, data.grit_max); syncCoreNumbers(); refreshAll(); saveAutosave(); });
    $("btnGritPlus").addEventListener("click", ()=>{ data.grit_cur = clamp(data.grit_cur+1, 0, data.grit_max); syncCoreNumbers(); refreshAll(); saveAutosave(); });
    $("btnFocusMinus").addEventListener("click", ()=>{ data.focus_cur = clamp(data.focus_cur-1, 0, data.focus_max); syncCoreNumbers(); refreshAll(); saveAutosave(); });
    $("btnFocusPlus").addEventListener("click", ()=>{ data.focus_cur = clamp(data.focus_cur+1, 0, data.focus_max); syncCoreNumbers(); refreshAll(); saveAutosave(); });

    $("newMenu").addEventListener("change", () => {
      const v = $("newMenu").value;
      $("newMenu").value = "";
      if(v === "blank") newBlank();
      if(v === "guided") openGuidedCreation();
    });

    $("btnMenu").addEventListener("click", openMobileMenu);

    $("btnOpen").addEventListener("click", ()=>$("jsonFile").click());
    $("jsonFile").addEventListener("change", onOpenJson);

    $("btnSave").addEventListener("click", exportJson);
    $("btnExportCards").addEventListener("click", exportCardPNGs);
    $("btnLevelUp").addEventListener("click", openLevelUp);
    $("btnClearAutosave").addEventListener("click", ()=>{ clearAutosave(); });

    $("portraitZoom").addEventListener("input", ()=>{
      setPortraitZoom(safeFloat($("portraitZoom").value, 1.0));
    });
    $("btnPortraitReset").addEventListener("click", ()=>{
      data.portrait.zoom = 1.0;
      data.portrait.offX = 0;
      data.portrait.offY = 0;
      refreshPortraitUI();
      renderPortrait();
      saveAutosave();
    });
    $("btnPortraitClear").addEventListener("click", ()=>{
      data.portrait.dataUrl = null;
      portraitImg = null;
      data.portrait.zoom = 1.0;
      data.portrait.offX = 0;
      data.portrait.offY = 0;
      $("portraitFile").value = "";
      refreshPortraitUI();
      renderPortrait();
      saveAutosave();
    });
    $("btnPortraitLock").addEventListener("click", ()=>{
      data.portrait.locked = !data.portrait.locked;
      updatePortraitLockUI();
      saveAutosave();
    });
    $("portraitFile").addEventListener("change", onPortraitFile);

    $("btnAddSkill").addEventListener("click", ()=>openSkillEditor(null));
  }

  function normaliseDerived(){
    data.level = clamp(safeInt(data.level,1), 1, 12);
    data.body  = clamp(safeInt(data.body,1), 1, 2);
    data.mind  = clamp(safeInt(data.mind,1), 1, 2);

    data.grit_max  = Math.max(0, safeInt(data.grit_max,0));
    data.focus_max = Math.max(0, safeInt(data.focus_max,0));
    data.dp_max    = Math.max(0, safeInt(data.dp_max,0));

    data.grit_cur  = clamp(safeInt(data.grit_cur,0), 0, data.grit_max);
    data.focus_cur = clamp(safeInt(data.focus_cur,0), 0, data.focus_max);
    data.dp_cur    = clamp(safeInt(data.dp_cur,0), 0, data.dp_max);

    if(!Array.isArray(data.skills)) data.skills = [];
    // PATCH: remove Signature tag support; coerce any invalid tags (including "S") to "B"
    for(const s of data.skills){
      if(!s || typeof s !== "object") continue;
      const t = String(s.tag || "B").toUpperCase().trim();
      s.tag = (t === "N" || t === "B") ? t : "B";
      s.dice = clamp(safeInt(s.dice,1), 1, 6);
      s.defensive = !!s.defensive;
      s.name = String(s.name || "").trim();
    }

    if(typeof data.features_text !== "string") data.features_text = "";
    if(typeof data.details !== "string") data.details = "";
    if(typeof data.wealth_other !== "string") data.wealth_other = "";
    data.wealth_coins = Math.max(0, safeInt(data.wealth_coins,0));

    if(typeof data.mastery_skill !== "string") data.mastery_skill = "";
    if(!(data.threat_assist_cost === null || Number.isFinite(safeInt(data.threat_assist_cost, NaN)))) data.threat_assist_cost = null;

    if(!data.advancement_log || typeof data.advancement_log !== "object"){
      data.advancement_log = { applied_levels: [] };
    }
    if(!Array.isArray(data.advancement_log.applied_levels)){
      data.advancement_log.applied_levels = [];
    } else {
      data.advancement_log.applied_levels = data.advancement_log.applied_levels
        .map(n => clamp(safeInt(n, 0), 0, 12))
        .filter(n => n >= 1 && n <= 12);
      data.advancement_log.applied_levels = [...new Set(data.advancement_log.applied_levels)];
    }

    if(!data.portrait || typeof data.portrait !== "object"){
      data.portrait = {dataUrl:null, zoom:1, offX:0, offY:0, locked:false};
    }
    data.portrait.zoom = clamp(safeFloat(data.portrait.zoom,1.0), 0.5, 3.0);
    data.portrait.offX = safeFloat(data.portrait.offX, 0);
    data.portrait.offY = safeFloat(data.portrait.offY, 0);
    data.portrait.locked = !!data.portrait.locked;
  }

  function syncInputsFromData(){
    $("name").value = data.name || "";
    $("level").value = String(data.level ?? 1);
    $("species").value = data.species || "";
    $("background").value = data.background || "";
    $("body").value = String(data.body ?? 1);
    $("mind").value = String(data.mind ?? 1);

    $("gritMax").value = String(data.grit_max ?? 0);
    $("gritCur").value = String(data.grit_cur ?? 0);
    $("focusMax").value = String(data.focus_max ?? 0);
    $("focusCur").value = String(data.focus_cur ?? 0);
    $("dpMax").value = String(data.dp_max ?? 0);
    $("dpCur").value = String(data.dp_cur ?? 0);

    $("features").value = data.features_text || "";
    $("details").value = data.details || "";
    $("detailsBig").value = data.details || "";
    $("wealthCoins").value = String(data.wealth_coins ?? 0);
    $("wealthOther").value = data.wealth_other || "";
    refreshPortraitUI();
  }

  function syncCoreNumbers(){
    $("gritCur").value = String(data.grit_cur);
    $("focusCur").value = String(data.focus_cur);
    $("dpCur").value = String(data.dp_cur);
  }

  function refreshVitals(){
    $("vName").textContent = (data.name || "â€”");
    $("vLevel").textContent = String(data.level ?? 1);
    $("vStats").textContent = `${data.body ?? 1} / ${data.mind ?? 1}`;
    $("vGrit").textContent = `${data.grit_cur ?? 0} / ${data.grit_max ?? 0}`;
    $("vFocus").textContent = `${data.focus_cur ?? 0} / ${data.focus_max ?? 0}`;
    $("vDice").textContent = `${data.dp_cur ?? 0} / ${data.dp_max ?? 0}`;
  }

  function refreshSuccessThreshold(){
    const skills = Array.isArray(data.skills) ? data.skills : [];
    const th = skills.some(s => !!(s && s.defensive)) ? 4 : 3;
    const el = $("kpiThreshold");
    if(el) el.textContent = `Success Threshold: ${th}+`;
  }

  function refreshSkills(){
    const list = $("skillsList");
    list.innerHTML = "";

    const skills = Array.isArray(data.skills) ? data.skills : [];
    if(skills.length === 0){
      const empty = document.createElement("div");
      empty.className = "pill";
      empty.textContent = "No skills yet";
      list.appendChild(empty);
      return;
    }

    for(let i=0;i<skills.length;i++){
      const s = skills[i];
      const tag = (s.tag === "N" || s.tag === "B") ? s.tag : "B";
      const dice = clamp(safeInt(s.dice,1), 1, 6);
      const def = !!s.defensive;

      const item = document.createElement("div");
      item.className = "item";

      const left = document.createElement("div");
      left.className = "left";
      left.style.flex = "1";
      left.style.minWidth = "0";

      const nm = document.createElement("div");
      nm.className = "name";
      nm.textContent = `(${tag}) ${s.name || "Unnamed"} â€” ${dice}d6${def ? " [DEF]" : ""}`;
      left.appendChild(nm);

      const meta = document.createElement("div");
      meta.className = "meta";
      meta.textContent = "Edit to change tag/dice/defensive.";
      left.appendChild(meta);

      const btns = document.createElement("div");
      btns.className = "row";

      const bEdit = document.createElement("button");
      bEdit.textContent = "Edit";
      bEdit.addEventListener("click", ()=>openSkillEditor({index:i, ...s}));

      const bDel = document.createElement("button");
      bDel.className = "danger";
      bDel.textContent = "Remove";
      bDel.addEventListener("click", ()=>{
        data.skills.splice(i,1);
        refreshAll(); saveAutosave();
      });

      btns.appendChild(bEdit);
      btns.appendChild(bDel);

      item.appendChild(left);
      item.appendChild(btns);
      list.appendChild(item);
    }
  }

  function refreshAll(){
    refreshVitals();
    refreshSkills();
    refreshSuccessThreshold();
    if($("detailsBig").value !== data.details) $("detailsBig").value = data.details || "";
    renderPortrait();  // Update front card preview
  }

  function setTab(name){
    document.querySelectorAll(".tab").forEach(t => t.classList.toggle("active", t.dataset.tab === name));
    $("tab-character").style.display = (name === "character") ? "" : "none";
    $("tab-details").style.display = (name === "details") ? "" : "none";
    $("tab-about").style.display = (name === "about") ? "" : "none";
  }
  document.querySelectorAll(".tab").forEach(t => {
    t.addEventListener("click", ()=>setTab(t.dataset.tab));
  });

  const modalBackdrop = $("modalBackdrop");
  const modalTitle = $("modalTitle");
  const modalBody = $("modalBody");
  const modalFooter = $("modalFooter");
  let modalPreventBackdropClose = false;

  function openModal({title, bodyNode, footerButtons=[], preventBackdropClose=false}){
    modalPreventBackdropClose = preventBackdropClose;
    modalTitle.textContent = title || "Menu";
    modalBody.innerHTML = "";
    if(bodyNode) modalBody.appendChild(bodyNode);
    modalFooter.innerHTML = "";
    footerButtons.forEach(b => modalFooter.appendChild(b));
    modalBackdrop.style.display = "flex";
    document.body.style.overflow = "hidden";
  }
  function closeModal(){
    modalPreventBackdropClose = false;
    modalBackdrop.style.display = "none";
    document.body.style.overflow = "";
    modalBody.innerHTML = "";
    modalFooter.innerHTML = "";
  }
  $("btnModalClose").addEventListener("click", ()=>{ if(!modalPreventBackdropClose) closeModal(); });
  modalBackdrop.addEventListener("click", (e)=>{ if(e.target === modalBackdrop && !modalPreventBackdropClose) closeModal(); });

  function openMobileMenu(){
    const wrap = document.createElement("div");
    wrap.className = "fields";

    const mkBtn = (text, cls, onClick) => {
      const b = document.createElement("button");
      b.textContent = text;
      if(cls) b.className = cls;
      b.addEventListener("click", ()=>{ closeModal(); onClick(); });
      return b;
    };

    const p = document.createElement("div");
    p.className = "span12";
    p.style.color = "var(--muted)";
    p.style.lineHeight = "1.5";
    p.innerHTML = `
      <div class="pill" style="display:inline-block; margin-bottom:10px;">Menu</div>
      <div>Open/Export/Level up/Card export live here on mobile.</div>
    `;
    wrap.appendChild(p);

    const row = document.createElement("div");
    row.className = "row";
    row.style.marginTop = "10px";
    row.appendChild(mkBtn("Openâ€¦", "", ()=>$("jsonFile").click()));
    row.appendChild(mkBtn("Export JSON", "primary", exportJson));
    row.appendChild(mkBtn("Export Card PNGs", "", exportCardPNGs));
    row.appendChild(mkBtn("Level Up", "", openLevelUp));
    row.appendChild(mkBtn("Clear Autosave", "danger", clearAutosave));
    wrap.appendChild(row);

    const closeBtn = document.createElement("button");
    closeBtn.textContent = "Close";
    closeBtn.addEventListener("click", closeModal);

    openModal({ title:"Menu", bodyNode: wrap, footerButtons:[closeBtn] });
  }

  function resetCharacterToBlank(){
    Object.assign(data, {
      name:"",
      level:1,
      species:"",
      background:"",
      body:1,
      mind:1,
      grit_max:4, grit_cur:4,
      focus_max:4, focus_cur:4,
      dp_max:0, dp_cur:0,
      skills:[],
      features_text:"",
      details:"",
      wealth_coins:0,
      wealth_other:"",
      mastery_skill:"",
      threat_assist_cost:null,
      advancement_log:{ applied_levels: [] },
      portrait:{ dataUrl:null, zoom:1.0, offX:0, offY:0, locked:data.portrait?.locked ?? false }
    });
    portraitImg = null;
    $("portraitFile").value = "";
    $("portraitZoom").value = "1.00";
  }

  function newBlank(){
    if(!confirm("Start a new blank character? This overwrites the current one.")) return;
    resetCharacterToBlank();
    normaliseDerived();
    syncInputsFromData();
    refreshAll();
    renderPortrait();
    saveAutosave();
    toast("New (Blank)");
  }

  const PRESET_SPECIES = ["Human","Dwarf","Elf","Seafolk","Custom"];
  const PRESET_BACKGROUNDS = ["Custom","Warrior","Mage","Priest","Thief","Ranger"];

  const BG_SKILLS = {
    Warrior:["Melee Weapons","Ranged Weapons","Manual Labour","Metalcraft"],
    Mage:["Magic: Elements","Magic: Warding","Academics","Parlour Magic"],
    Priest:["Magic: Healing","Melee Weapons","Faith","Insight"],
    Thief:["Melee Weapons","Roguery","Stealth","Social Manipulation"],
    Ranger:["Ranged Weapons","Scout","Vigilance","Natural World"]
  };

  const TRAIT_EXAMPLES = ["Lowlight Vision","Underwater Adaptions","Heat Resistance"];

  const FEAT_TEMPLATES = [
    { id:"learned", name:"Learned", desc:"Learn 3 additional skills.", learned:true, fields:[] },
    { id:"tough", name:"Tough",
      desc:"Due to your {{aspect}}, whenever you take {{pool}} damage, reduce it by 1.",
      learned:false,
      fields:[
        { key:"aspect", label:"Character Aspect", type:"text" },
        { key:"pool", label:"Grit or Focus", type:"choice", options:["Grit","Focus"] }
      ]
    },
    { id:"resistant", name:"Resistant",
      desc:"Due to your {{aspect}}, reduce {{type}} damage by 2.",
      learned:false,
      fields:[
        { key:"aspect", label:"Character Aspect", type:"text" },
        { key:"type", label:"Type", type:"text" }
      ]
    },
    { id:"dealer", name:"Dealer",
      desc:"When you roll to Fight or Major Impact with {{skill}}, add one additional Success.",
      learned:false,
      fields:[ { key:"skill", label:"Skill", type:"skill" } ]
    },
    { id:"martyr", name:"Martyr",
      desc:"When you're below half your total {{pool}}, your Fight or Major Impact Successes create Opportunity for your allies.",
      learned:false,
      fields:[ { key:"pool", label:"Grit or Focus", type:"choice", options:["Grit","Focus"] } ]
    },
    { id:"defiant", name:"Defiant",
      desc:"Once per combat, when you reach death's door, regain 1 Grit and 1 Focus.",
      learned:false, fields:[]
    },
    { id:"reckless", name:"Reckless",
      desc:"Once per check, when you spend 6 {{pool}} to push a roll, deal an additional Success.",
      learned:false,
      fields:[ { key:"pool", label:"Grit or Focus", type:"choice", options:["Grit","Focus"] } ]
    },
    { id:"guardian", name:"Guardian",
      desc:"Once per round, when a nearby ally would take damage, you may redirect that damage to yourself and reduce it by 1.",
      learned:false, fields:[]
    },
    { id:"reliable", name:"Reliable",
      desc:"Once per check, when you roll a 1 on a {{skill}} check, re-roll all 1s and use the new results.",
      learned:false,
      fields:[ { key:"skill", label:"Skill", type:"skill" } ]
    },
    { id:"efficient", name:"Efficient",
      desc:"When you push a {{skill}} roll, increase the roll by 2 for each point of Grit or Focus spent.",
      learned:false,
      fields:[ { key:"skill", label:"Skill", type:"skill" } ]
    },
    { id:"specialist", name:"Specialist",
      desc:"When you use {{narrowSkill}}, add one additional Success to your roll.",
      learned:false,
      fields:[ { key:"narrowSkill", label:"Narrow Skill", type:"skill" } ]
    },
    { id:"ranger", name:"Ranger",
      desc:"In {{environment}}, add an additional Success when making {{skill}} checks.",
      learned:false,
      fields:[
        { key:"environment", label:"Environment", type:"text" },
        { key:"skill", label:"Skill", type:"skill" }
      ]
    },
    { id:"alchemist", name:"Alchemist",
      desc:"When combining {{skill1}} with {{skill2}}, add an additional Success instead of adding +1.",
      learned:false,
      fields:[
        { key:"skill1", label:"Skill (first)", type:"skill" },
        { key:"skill2", label:"Skill (second)", type:"skill" }
      ]
    },
    { id:"cooperative", name:"Cooperative",
      desc:"When you combine your skill with an ally's on a group check, add an additional Success to your roll.",
      learned:false, fields:[]
    },
    { id:"vengeful", name:"Vengeful",
      desc:"In combat, whenever you take 6 damage from a single source, deal an immediate Success in retaliation.",
      learned:false, fields:[]
    },
    { id:"trait", name:"Trait",
      desc:"Due to your {{aspect}}, you now have {{trait}}.",
      learned:false,
      fields:[
        { key:"aspect", label:"Character Aspect", type:"text" },
        { key:"trait", label:"Trait", type:"text" }
      ]
    }
  ];

  function getFeatTemplate(id){
    return FEAT_TEMPLATES.find(f => f.id === id) || null;
  }

  function fillTemplate(str, vars){
    return String(str||"").replace(/\{\{(\w+)\}\}/g, (_, k) => {
      const v = (vars && Object.prototype.hasOwnProperty.call(vars, k)) ? vars[k] : "";
      return String(v ?? "").trim();
    });
  }

  function openGuidedCreation(){
    const state = {
      step: 0,
      stepChanged: "",
      name: "",
      species: "Human",
      background: "Warrior",
      baseGrit: 4,
      baseFocus: 4,
      thiefWeapon: "Melee Weapons",
      customBonusGrit: 0,
      customBonusFocus: 0,
      customTraitsText: "",
      skills: []
    };

    const steps = [
      { title:"Name", render: renderStepName },
      { title:"Species", render: renderStepSpecies },
      { title:"Background", render: renderStepBackground },
      { title:"Grit / Focus", render: renderStepPools },
      { title:"Starting Skills", render: renderStepSkills }
    ];

    function speciesMeta(){
      if(state.species === "Human") return { bg:1, bf:1, extraSkill:1, traits:[] };
      if(state.species === "Dwarf") return { bg:2, bf:0, extraSkill:0, traits:["Lowlight Vision"] };
      if(state.species === "Elf") return { bg:0, bf:3, extraSkill:0, traits:[] };
      if(state.species === "Seafolk") return { bg:1, bf:1, extraSkill:0, traits:["Underwater Adaptions"] };
      if(state.species === "Custom"){
        const bg = clamp(safeInt(state.customBonusGrit,0), 0, 3);
        const bf = clamp(safeInt(state.customBonusFocus,0), 0, 3);
        const used = bg + bf;
        const traitPoints = clamp(3 - used, 0, 3);
        const typed = (state.customTraitsText||"")
          .split(/[\n,]+/)
          .map(s=>s.trim())
          .filter(Boolean)
          .slice(0, traitPoints);
        return { bg, bf, extraSkill:0, traits: typed };
      }
      return { bg:0, bf:0, extraSkill:0, traits:[] };
    }

    function isSeedDefensiveSkill(nm){
      const n = String(nm||"").trim();
      return (n === "Magic: Warding" || n === "Magic: Wards");
    }

    function seedSkillsFromBackground(){
      if(state.background === "Custom"){
        state.skills = [];
        return;
      }
      const base = (BG_SKILLS[state.background] || []).slice(0, 4);
      if(state.background === "Thief"){
        base[0] = state.thiefWeapon;
      }
      state.skills = base.map(nm => ({ name:nm, tag:"B", dice:1, defensive:isSeedDefensiveSkill(nm) }));
    }

    seedSkillsFromBackground();

    function rerender(){
      const wrap = document.createElement("div");
      wrap.className = "fields";

      const head = document.createElement("div");
      head.className = "span12";
      head.style.color = "var(--muted)";
      head.style.marginBottom = "6px";
      head.innerHTML = `<div class="pill">Step ${state.step+1} / ${steps.length}</div> <span style="margin-left:8px;">${steps[state.step].title}</span>`;
      wrap.appendChild(head);

      const body = steps[state.step].render();
      wrap.appendChild(body);

      const btnBack = document.createElement("button");
      btnBack.textContent = "Back";
      btnBack.disabled = state.step === 0;
      btnBack.addEventListener("click", ()=>{ state.step = Math.max(0, state.step-1); rerender(); });

      const btnNext = document.createElement("button");
      btnNext.className = "primary";
      btnNext.textContent = (state.step === steps.length-1) ? "Apply" : "Next";
      btnNext.addEventListener("click", ()=>{
        if(state.step === 0 && !state.name.trim()){ toast("Name required"); return; }
        if(state.step < steps.length-1){
          state.step++;
          rerender();
        }else{
          resetCharacterToBlank();

          const sm = speciesMeta();
          const gritMax = clamp(safeInt(state.baseGrit,4), 0, 8) + sm.bg;
          const focusMax = clamp(safeInt(state.baseFocus,4), 0, 8) + sm.bf;

          data.name = state.name.trim();
          data.species = state.species;
          data.background = state.background;

          data.grit_max = gritMax;
          data.grit_cur = gritMax;
          data.focus_max = focusMax;
          data.focus_cur = focusMax;

          data.skills = state.skills.slice(0);

          if(sm.traits.length){
            const lines = sm.traits.map(t => `â€¢ Trait: ${t}`);
            data.features_text = lines.join("\n");
          }

          normaliseDerived();
          syncInputsFromData();
          refreshAll();
          renderPortrait();
          saveAutosave();
          closeModal();
          toast("New (Guided)");
        }
      });

      const btnCancel = document.createElement("button");
      btnCancel.className = "danger";
      btnCancel.textContent = "Cancel";
      btnCancel.addEventListener("click", closeModal);

      openModal({
        title: "New (Guided Creation)",
        bodyNode: wrap,
        footerButtons: [btnCancel, btnBack, btnNext],
        preventBackdropClose: true
      });
    }

    function renderStepName(){
      const box = document.createElement("div");
      box.className = "field span12";
      box.innerHTML = `<label>Name</label><input id="wizName" type="text" enterkeyhint="done" autocomplete="off" />`;
      const el = box.querySelector("#wizName");
      el.value = state.name;
      el.addEventListener("input", ()=>{ state.name = el.value; });
      setTimeout(()=>el.focus(), 60);
      return box;
    }

    function renderStepSpecies(){
      const box = document.createElement("div");
      box.className = "field span12";

      const opts = PRESET_SPECIES.map(s=>`<option value="${s}">${s}</option>`).join("");
      box.innerHTML = `
        <label>Species</label>
        <select id="wizSpecies">${opts}</select>

        <div id="speciesInfo" style="margin-top:10px; color:var(--muted); line-height:1.5;"></div>

        <div id="customBlock" style="margin-top:10px; display:none;">
          <div class="pill">Custom: +3 split between Grit, Focus, and Traits</div>
          <div style="height:10px;"></div>
          <div class="fields">
            <div class="field span6">
              <label>+Grit (0â€“3)</label>
              <input id="cGrit" type="number" min="0" max="3" step="1">
            </div>
            <div class="field span6">
              <label>+Focus (0â€“3)</label>
              <input id="cFocus" type="number" min="0" max="3" step="1">
            </div>
            <div class="field span12">
              <label>Traits (up to remaining points)</label>
              <textarea id="cTraits" class="mono" style="min-height:90px;" placeholder="Lowlight Vision&#10;Underwater Adaptions"></textarea>
              <div class="pill" id="cRemain" style="margin-top:8px;">Traits points: 3</div>
              <div class="pill" style="margin-top:8px;">Examples: ${TRAIT_EXAMPLES.join(", ")}</div>
            </div>
          </div>
        </div>
      `;

      const sel = box.querySelector("#wizSpecies");
      const info = box.querySelector("#speciesInfo");
      const customBlock = box.querySelector("#customBlock");
      const cG = box.querySelector("#cGrit");
      const cF = box.querySelector("#cFocus");
      const cT = box.querySelector("#cTraits");
      const cR = box.querySelector("#cRemain");

      sel.value = state.species;
      cG.value = String(state.customBonusGrit);
      cF.value = String(state.customBonusFocus);
      cT.value = String(state.customTraitsText || "");

      function update(){
        state.species = sel.value;
        customBlock.style.display = (state.species === "Custom") ? "" : "none";

        const sm = speciesMeta();
        if(state.species === "Human") info.textContent = "Human: +1 Grit, +1 Focus, +1 bonus skill.";
        else if(state.species === "Dwarf") info.textContent = "Dwarf: +2 Grit, Trait: Lowlight Vision.";
        else if(state.species === "Elf") info.textContent = "Elf: +3 Focus.";
        else if(state.species === "Seafolk") info.textContent = "Seafolk: +1 Grit, +1 Focus, Trait: Underwater Adaptions.";
        else if(state.species === "Custom"){
          const used = sm.bg + sm.bf;
          const traitPts = clamp(3 - used, 0, 3);
          info.textContent = `Custom: +${sm.bg} Grit, +${sm.bf} Focus, ${traitPts} trait point(s).`;
          cR.textContent = `Traits points: ${traitPts}`;
        } else info.textContent = "";
      }

      function enforceCustomSum(changed){
        let bg = clamp(safeInt(cG.value,0), 0, 3);
        let bf = clamp(safeInt(cF.value,0), 0, 3);
        if(bg + bf > 3){
          if(changed === "G"){
            bf = Math.max(0, 3 - bg);
            cF.value = String(bf);
          }else{
            bg = Math.max(0, 3 - bf);
            cG.value = String(bg);
          }
        }
        state.customBonusGrit = bg;
        state.customBonusFocus = bf;
        state.customTraitsText = cT.value || "";
        update();
      }

      sel.addEventListener("change", ()=>{ update(); rerender(); });
      cG.addEventListener("input", ()=>enforceCustomSum("G"));
      cF.addEventListener("input", ()=>enforceCustomSum("F"));
      cT.addEventListener("input", ()=>{ state.customTraitsText = cT.value || ""; update(); });

      update();
      return box;
    }

    function renderStepBackground(){
      const box = document.createElement("div");
      box.className = "field span12";

      const opts = PRESET_BACKGROUNDS.map(s=>`<option value="${s}">${s}</option>`).join("");
      box.innerHTML = `
        <label>Background</label>
        <select id="wizBg">${opts}</select>

        <div id="bgInfo" style="margin-top:10px; color:var(--muted); line-height:1.5;"></div>

        <div id="thiefChoice" style="margin-top:10px; display:none;">
          <label>Thief weapon skill</label>
          <select id="thiefWeapon">
            <option value="Melee Weapons">Melee Weapons</option>
            <option value="Ranged Weapons">Ranged Weapons</option>
          </select>
        </div>
      `;

      const sel = box.querySelector("#wizBg");
      const info = box.querySelector("#bgInfo");
      const thiefWrap = box.querySelector("#thiefChoice");
      const thiefSel = box.querySelector("#thiefWeapon");

      sel.value = state.background;
      thiefSel.value = state.thiefWeapon;

      function update(){
        state.background = sel.value;
        thiefWrap.style.display = (state.background === "Thief") ? "" : "none";

        if(state.background === "Custom") info.textContent = "Custom: choose 4 starting skills in the next step.";
        else{
          const list = BG_SKILLS[state.background] || [];
          if(state.background === "Thief"){
            info.textContent = `Thief: ${state.thiefWeapon}, Roguery, Stealth, Social Manipulation.`;
          }else{
            info.textContent = `${state.background}: ${list.join(", ")}.`;
          }
        }

        seedSkillsFromBackground();
      }

      sel.addEventListener("change", ()=>{ update(); });
      thiefSel.addEventListener("change", ()=>{ state.thiefWeapon = thiefSel.value; update(); });

      update();
      return box;
    }

    function renderStepPools(){
      const box = document.createElement("div");
      box.className = "field span12";
      box.innerHTML = `
        <div class="pill">Spend 8 points between Grit and Focus (species bonuses apply on top)</div>
        <div style="height:10px"></div>
        <div class="fields">
          <div class="field span6">
            <label>Base Grit</label>
            <input id="wizG" type="number" min="0" max="8" step="1">
          </div>
          <div class="field span6">
            <label>Base Focus</label>
            <input id="wizF" type="number" min="0" max="8" step="1">
          </div>
          <div class="field span12">
            <div class="pill" id="wizSum">Base Total: 8 / 8</div>
            <div class="pill" id="wizFinal" style="margin-left:8px;">Final: â€”</div>
          </div>
        </div>
      `;
      const g = box.querySelector("#wizG");
      const f = box.querySelector("#wizF");
      const sum = box.querySelector("#wizSum");
      const fin = box.querySelector("#wizFinal");
      g.value = state.baseGrit;
      f.value = state.baseFocus;

      function sync(changed){
        let gg = clamp(safeInt(g.value,4), 0, 8);
        let ff = clamp(safeInt(f.value,4), 0, 8);
        const total = gg + ff;

        if(total !== 8){
          if(changed === "G"){
            ff = clamp(8 - gg, 0, 8);
            f.value = String(ff);
          }else if(changed === "F"){
            gg = clamp(8 - ff, 0, 8);
            g.value = String(gg);
          }else{
            // fallback (shouldn't happen), preserve old behaviour
            if(document.activeElement === g){
              ff = clamp(8 - gg, 0, 8);
              f.value = String(ff);
            }else{
              gg = clamp(8 - ff, 0, 8);
              g.value = String(gg);
            }
          }
        }

        state.baseGrit = gg;
        state.baseFocus = ff;
        sum.textContent = `Base Total: ${state.baseGrit + state.baseFocus} / 8`;

        const sm = speciesMeta();
        fin.textContent = `Final: Grit ${state.baseGrit + sm.bg}, Focus ${state.baseFocus + sm.bf}`;
      }

      g.addEventListener("input", ()=>sync("G"));
      f.addEventListener("input", ()=>sync("F"));
      sync("G");
      return box;
    }

    function renderStepSkills(){
      const box = document.createElement("div");
      box.className = "field span12";

      const sm = speciesMeta();
      const required = 4 + (sm.extraSkill || 0);

      const header = document.createElement("div");
      header.style.display = "flex";
      header.style.alignItems = "center";
      header.style.justifyContent = "space-between";
      header.style.gap = "10px";

      const pill = document.createElement("div");
      pill.className = "pill";
      pill.textContent = `Choose ${required} starting skills`;
      header.appendChild(pill);

      const addBtn = document.createElement("button");
      addBtn.className = "primary";
      addBtn.textContent = "Add Skill";
      addBtn.addEventListener("click", ()=>{
        if(state.skills.length >= required){
          toast(`Max ${required} skill(s) in guided creation`);
          return;
        }
        openSkillEditor(null, (created)=>{
          state.skills.push(created);
        }, rerender);
      });
      header.appendChild(addBtn);
      box.appendChild(header);

      const humanHelp = document.createElement("div");
      humanHelp.style.marginTop = "10px";
      humanHelp.style.color = "var(--muted)";
      humanHelp.style.lineHeight = "1.5";
      humanHelp.style.display = (state.species === "Human") ? "" : "none";
      humanHelp.textContent = "Human: you get one bonus skill (total 5).";
      box.appendChild(humanHelp);

      if(state.background !== "Custom" && state.skills.length === 0) seedSkillsFromBackground();

      const list = document.createElement("div");
      list.className = "list";
      list.style.marginTop = "10px";
      box.appendChild(list);

      function draw(){
        if(state.skills.length > required) state.skills = state.skills.slice(0, required);

        list.innerHTML = "";

        const countPill = document.createElement("div");
        countPill.className = "pill";
        countPill.textContent = `Selected: ${state.skills.length} / ${required}`;
        list.appendChild(countPill);

        if(state.skills.length === 0){
          const p = document.createElement("div");
          p.className = "pill";
          p.textContent = "No skills yet";
          list.appendChild(p);
        }

        state.skills.forEach((s, idx)=>{
          const row = document.createElement("div");
          row.className = "item";
          const left = document.createElement("div");
          left.className = "left";
          left.style.flex="1";
          left.style.minWidth="0";
          const nm = document.createElement("div");
          nm.className = "name";
          nm.textContent = `(${s.tag||"B"}) ${s.name||"Unnamed"} â€” ${clamp(safeInt(s.dice,1),1,6)}d6${s.defensive?" [DEF]":""}`;
          left.appendChild(nm);

          const btns = document.createElement("div");
          btns.className = "row";
          const b = document.createElement("button");
          b.textContent = "Edit";
          b.addEventListener("click", ()=>{
            openSkillEditor({ index: idx, ...s }, (updated)=>{
              state.skills[idx] = updated;
            }, rerender);
          });
          const d = document.createElement("button");
          d.className="danger";
          d.textContent="Remove";
          d.addEventListener("click", ()=>{ state.skills.splice(idx,1); draw(); });
          btns.appendChild(b); btns.appendChild(d);

          row.appendChild(left); row.appendChild(btns);
          list.appendChild(row);
        });

        if(state.background !== "Custom"){
          const resetBtn = document.createElement("button");
          resetBtn.textContent = "Reset to background skills";
          resetBtn.addEventListener("click", ()=>{
            seedSkillsFromBackground();
            if(state.species === "Human") state.skills = state.skills.slice(0, 4);
            draw();
          });
          list.appendChild(resetBtn);
        }
      }

      if(state.background === "Thief"){
        const expected0 = state.thiefWeapon;
        if(state.skills.length > 0 && state.skills[0] && state.skills[0].name !== expected0){
          const seeded = BG_SKILLS.Thief;
          const looksSeeded = state.skills.length === 4 && state.skills.slice(1).every((x,i)=>x.name === seeded[i+1]);
          if(looksSeeded) state.skills[0].name = expected0;
        }
      }

      if(state.species !== "Human" && state.skills.length > 4) state.skills = state.skills.slice(0, 4);
      draw();
      return box;
    }

    rerender();
  }

  // --- Skill editor (reusable) + wizard override
  function openSkillEditor(preset, onOkOverride, onCancelOverride){
    const isWizard = typeof onOkOverride === "function";
    const wizardReturn = (typeof onCancelOverride === "function") ? onCancelOverride : null;

    const s0 = preset ? { ...preset } : { name:"", tag:"B", dice:1, defensive:false };
    const wrap = document.createElement("div");
    wrap.className = "fields";

    const fName = document.createElement("div");
    fName.className = "field span12";
    fName.innerHTML = `<label>Name</label><input id="skName" type="text" enterkeyhint="done">`;
    wrap.appendChild(fName);

    const fTag = document.createElement("div");
    fTag.className = "field span4";
    /* PATCH: remove Signature tag option */
    fTag.innerHTML = `
      <label>Tag</label>
      <select id="skTag">
        <option value="B">(B) Broad</option>
        <option value="N">(N) Narrow</option>
      </select>
    `;
    wrap.appendChild(fTag);

    const fDice = document.createElement("div");
    fDice.className = "field span4";
    fDice.innerHTML = `<label>Dice</label><input id="skDice" type="number" min="1" max="6" step="1">`;
    wrap.appendChild(fDice);

    const fDef = document.createElement("div");
    fDef.className = "field span4";
    fDef.innerHTML = `<label style="display:flex; gap:8px; align-items:center;">
      <input id="skDef" type="checkbox" style="width:auto;"> Defensive
    </label>`;
    wrap.appendChild(fDef);

    const nameEl = wrap.querySelector("#skName");
    const tagEl  = wrap.querySelector("#skTag");
    const diceEl = wrap.querySelector("#skDice");
    const defEl  = wrap.querySelector("#skDef");

    nameEl.value = s0.name || "";
    tagEl.value  = (s0.tag === "N" || s0.tag === "B") ? s0.tag : "B";
    diceEl.value = String(clamp(safeInt(s0.dice,1),1,6));
    defEl.checked = !!s0.defensive;

    const btnCancel = document.createElement("button");
    btnCancel.className = "danger";
    btnCancel.textContent = "Cancel";
    btnCancel.addEventListener("click", ()=>{
      if(isWizard && wizardReturn){
        wizardReturn();
        return;
      }
      closeModal();
    });

    const btnOK = document.createElement("button");
    btnOK.className = "primary";
    btnOK.textContent = "OK";
    btnOK.addEventListener("click", ()=>{
      const name = (nameEl.value||"").trim();
      if(!name){ toast("Skill name required"); return; }
      const skill = {
        name,
        tag: (tagEl.value === "N" ? "N" : "B"),
        dice: clamp(safeInt(diceEl.value,1), 1, 6),
        defensive: !!defEl.checked
      };

      if(isWizard){
        onOkOverride(skill);
        if(wizardReturn) wizardReturn();
        return;
      }

      if(preset && Number.isFinite(preset.index)){
        data.skills[preset.index] = skill;
      }else{
        data.skills.push(skill);
      }
      normaliseDerived();
      refreshAll();
      saveAutosave();
      closeModal();
    });

    openModal({
      title: preset ? "Edit Skill" : "Add Skill",
      bodyNode: wrap,
      footerButtons: [btnCancel, btnOK]
    });

    setTimeout(()=>nameEl.focus(), 60);
  }

  // --- JSON export/import
  function safeFileName(name){
    const base = (name||"Character").trim() || "Character";
    return base
      .replace(/[^\w\- ]+/g, "")
      .replace(/\s+/g, "_")
      .slice(0, 48);
  }
  function downloadText(filename, text, mime){
    const blob = new Blob([text], {type: mime || "text/plain"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 500);
  }
  function exportJson(){
    normaliseDerived();
    const filename = safeFileName(data.name) + ".json";
    downloadText(filename, JSON.stringify(data, null, 2), "application/json");
    toast("Exported JSON");
  }
  function onOpenJson(){
    const f = $("jsonFile").files?.[0];
    $("jsonFile").value = "";
    if(!f) return;

    const reader = new FileReader();
    reader.onload = () => {
      try{
        const obj = JSON.parse(String(reader.result||""));
        if(!obj || typeof obj !== "object") throw new Error("Bad JSON");
        Object.assign(data, obj);
        if(obj.portrait) Object.assign(data.portrait, obj.portrait);
        normaliseDerived();
        syncInputsFromData();
        refreshAll();
        loadPortraitFromDataUrl(data.portrait.dataUrl);
        renderPortrait();
        saveAutosave();
        toast("Opened JSON");
      }catch(e){
        toast("Invalid JSON");
      }
    };
    reader.readAsText(f);
  }

  // --- Level Up
  function openLevelUp(){
    normaliseDerived();

    const fromLevel = clamp(safeInt(data.level,1), 1, 12);
    const toLevel = clamp(fromLevel + 1, 1, 12);

    if(fromLevel >= 12){
      toast("Already level 12");
      return;
    }

    const alreadyApplied = (data.advancement_log?.applied_levels || []).includes(toLevel);

    const lu = {
      step: 0,
      fromLevel,
      toLevel,
      allocG: 0,
      allocF: 0,
      bonusChoice: "", // "skill" | "grit" | "focus"
      bonusSkill: null,
      milestone: {
        featTemplateId: "",
        featVars: {},
        customFeatName: "",
        customFeatDesc: "",
        featName: "",
        featDesc: "",
        learned: false,
        learnedSkills: [],
        statPick: "",
        masterySkill: ""
      }
    };

    const needsFeat = [3,8,12].includes(toLevel);
    const needsStat = (toLevel === 5);
    const needsThreatAssist = (toLevel === 6);
    const needsMastery = (toLevel === 10);

    const steps = [
      { key:"alloc", title:"+4 to max pools", render: renderAlloc },
      { key:"bonus", title:"Choose one bonus", render: renderBonus }
    ];
    if(needsFeat || needsStat || needsThreatAssist || needsMastery){
      steps.push({ key:"milestone", title:"Milestone", render: renderMilestone });
    }
    steps.push({ key:"dice", title:"Strive Dice (max)", render: renderDice });
    steps.push({ key:"summary", title:"Summary", render: renderSummary });

    let btnNextRef = null;
    function updateNextDisabled(){
      if(btnNextRef) btnNextRef.disabled = !canProceedFromStep(lu.step);
    }

    function gatherAllNewSkills(){
      const out = [];
      if(lu.bonusChoice === "skill" && lu.bonusSkill) out.push(lu.bonusSkill);
      if(lu.milestone.learned && Array.isArray(lu.milestone.learnedSkills)){
        out.push(...lu.milestone.learnedSkills);
      }
      return out;
    }

    function skillsForPick(){
      const base = Array.isArray(data.skills) ? data.skills.slice(0) : [];
      const extra = gatherAllNewSkills();
      const combined = base.concat(extra);
      const names = combined.map(s => (s?.name || "").trim()).filter(Boolean);
      return [...new Set(names)];
    }

    function computeFeat(){
      const id = (lu.milestone.featTemplateId || "").trim();
      if(!id){
        return { id:"", name:"", desc:"", learned:false, missing:["Feat"] };
      }

      if(id === "custom"){
        const name = (lu.milestone.customFeatName || "").trim();
        const desc = (lu.milestone.customFeatDesc || "").trim();
        const missing = [];
        if(!name) missing.push("Feat name");
        return { id, name, desc, learned:false, missing };
      }

      const t = getFeatTemplate(id);
      if(!t){
        return { id:"", name:"", desc:"", learned:false, missing:["Feat"] };
      }

      const vars = (lu.milestone.featVars && typeof lu.milestone.featVars === "object") ? lu.milestone.featVars : {};
      const missing = [];
      for(const f of (t.fields || [])){
        const v = String(vars[f.key] ?? "").trim();
        if(!v) missing.push(f.label);
      }

      const desc = fillTemplate(t.desc, vars).replace(/\s+/g, " ").trim();
      return { id:t.id, name:t.name, desc, learned:!!t.learned, missing };
    }

    function syncFeatDerived(){
      const feat = computeFeat();
      lu.milestone.featName = feat.name || "";
      lu.milestone.featDesc = feat.desc || "";
      lu.milestone.learned = !!feat.learned;
      return feat;
    }

    function setFeatLinePreview(){
      const feat = syncFeatDerived();
      const nm = (feat.name||"").trim();
      const ds = (feat.desc||"").trim();
      if(!nm) return "";
      const dash = ds ? ` â€” ${ds}` : "";
      return `â€¢ [L${toLevel}] Feat: ${nm}${dash}`;
    }

    function rerender(){
      const wrap = document.createElement("div");
      wrap.className = "fields";

      const head = document.createElement("div");
      head.className = "span12";
      head.style.color = "var(--muted)";
      head.style.marginBottom = "6px";
      head.innerHTML = `<div class="pill">Step ${lu.step+1} / ${steps.length}</div> <span style="margin-left:8px;">${steps[lu.step].title}</span>`;
      wrap.appendChild(head);

      const body = steps[lu.step].render();
      wrap.appendChild(body);

      const btnCancel = document.createElement("button");
      btnCancel.className = "danger";
      btnCancel.textContent = "Cancel";
      btnCancel.addEventListener("click", closeModal);

      const btnBack = document.createElement("button");
      btnBack.textContent = "Back";
      btnBack.disabled = (lu.step === 0);
      btnBack.addEventListener("click", ()=>{ lu.step = Math.max(0, lu.step-1); rerender(); });

      const btnNext = document.createElement("button");
      btnNext.className = "primary";
      btnNext.textContent = (lu.step === steps.length - 1) ? "Apply" : "Next";

      btnNextRef = btnNext;
      updateNextDisabled();

      btnNext.addEventListener("click", ()=>{
        if(lu.step < steps.length - 1){
          lu.step++;
          rerender();
          return;
        }
        applyLevelUp();
      });

      openModal({
        title: "Level Up",
        bodyNode: wrap,
        footerButtons: [btnCancel, btnBack, btnNext],
        preventBackdropClose: true
      });
    }

    function canProceedFromStep(stepIdx){
      const k = steps[stepIdx].key;

      if(k === "alloc"){
        return (lu.allocG + lu.allocF) === 4;
      }

      if(k === "bonus"){
        if(lu.bonusChoice === "grit" || lu.bonusChoice === "focus") return true;
        if(lu.bonusChoice === "skill") return !!lu.bonusSkill;
        return false;
      }

      if(k === "milestone"){
        if(needsFeat){
          const feat = syncFeatDerived();
          if(!feat.name.trim()) return false;
          if(feat.missing && feat.missing.length) return false;
          if(feat.learned){
            return (lu.milestone.learnedSkills.length === 3);
          }
        }
        if(needsStat){
          const canBody = (data.body ?? 1) < 2;
          const canMind = (data.mind ?? 1) < 2;
          if(canBody || canMind){
            return (lu.milestone.statPick === "body" || lu.milestone.statPick === "mind");
          }
        }
        if(needsMastery){
          const m = (lu.milestone.masterySkill||"").trim();
          if(!m) return false;
        }
        return true;
      }

      return true;
    }

    function renderAlloc(){
      const box = document.createElement("div");
      box.className = "field span12";

      const warn = alreadyApplied
        ? `<div class="pill" style="border-color: rgba(255,92,92,.55); color: var(--text); background: rgba(255,92,92,.10); margin-top:10px;">
             Warning: Level ${toLevel} was already applied by the wizard. Applying again will stack benefits.
           </div>`
        : "";

      box.innerHTML = `
        <div class="pill">Guided rules wizard</div>
        <div style="margin-top:8px; color:var(--muted); line-height:1.5;">
          Levelling from <b style="color:var(--text)">Level ${fromLevel}</b> â†’ <b style="color:var(--text)">Level ${toLevel}</b>.
        </div>
        <div style="margin-top:8px; color:var(--muted); line-height:1.5;">
          
        </div>
        ${warn}

        <div style="height:12px;"></div>

        <div class="pill">Spend +4 between max Grit and max Focus</div>
        <div style="height:10px;"></div>
        <div class="fields">
          <div class="field span6">
            <label>+Grit (max)</label>
            <input id="luAllocG" type="number" min="0" max="4" step="1">
          </div>
          <div class="field span6">
            <label>+Focus (max)</label>
            <input id="luAllocF" type="number" min="0" max="4" step="1">
          </div>
          <div class="field span12">
            <div class="pill" id="luRemain">Remaining: 4</div>
            <div class="pill" id="luPreview" style="margin-left:8px;">Preview: â€”</div>
          </div>
        </div>
      `;

      const g = box.querySelector("#luAllocG");
      const f = box.querySelector("#luAllocF");
      const remain = box.querySelector("#luRemain");
      const preview = box.querySelector("#luPreview");

      g.value = String(lu.allocG);
      f.value = String(lu.allocF);

      function sync(changed){
        let gg = clamp(safeInt(g.value,0), 0, 4);
        let ff = clamp(safeInt(f.value,0), 0, 4);
        const total = gg + ff;

        if(total > 4){
          if(changed === "G"){
            ff = clamp(4 - gg, 0, 4);
            f.value = String(ff);
          }else{
            gg = clamp(4 - ff, 0, 4);
            g.value = String(gg);
          }
        }

        lu.allocG = gg;
        lu.allocF = ff;

        const rem = 4 - (lu.allocG + lu.allocF);
        remain.textContent = `Remaining: ${rem}`;
        preview.textContent = `Preview: Grit max ${data.grit_max + lu.allocG}, Focus max ${data.focus_max + lu.allocF}`;

        updateNextDisabled();
      }

      g.addEventListener("input", ()=>sync("G"));
      f.addEventListener("input", ()=>sync("F"));
      sync("G");

      return box;
    }

    function renderBonus(){
      const box = document.createElement("div");
      box.className = "field span12";

      box.innerHTML = `
        <div class="pill">Choose one</div>
        <div style="height:10px;"></div>

        <div style="display:flex; flex-direction:column; gap:10px;">
          <label style="display:flex; gap:8px; align-items:center;">
            <input type="radio" name="luBonus" value="skill" style="width:auto;">
            Gain 1 new skill
          </label>

          <label style="display:flex; gap:8px; align-items:center;">
            <input type="radio" name="luBonus" value="grit" style="width:auto;">
            +2 to Grit max
          </label>

          <label style="display:flex; gap:8px; align-items:center;">
            <input type="radio" name="luBonus" value="focus" style="width:auto;">
            +2 to Focus max
          </label>
        </div>

        <div id="luSkillBlock" style="margin-top:12px; display:none;">
          <div class="pill">New skill</div>
          <div style="height:8px;"></div>
          <div class="row">
            <button class="primary" id="luAddSkill" type="button">Add / Edit Skill</button>
            <span class="pill" id="luSkillSummary">None</span>
          </div>
        </div>
      `;

      const radios = [...box.querySelectorAll('input[name="luBonus"]')];
      const skillBlock = box.querySelector("#luSkillBlock");
      const skillSummary = box.querySelector("#luSkillSummary");
      const addSkillBtn = box.querySelector("#luAddSkill");

      function updateSkillSummary(){
        if(!lu.bonusSkill){
          skillSummary.textContent = "None";
          return;
        }
        const s = lu.bonusSkill;
        const tag = (s.tag === "N" ? "N" : "B");
        const dice = clamp(safeInt(s.dice,1), 1, 6);
        skillSummary.textContent = `(${tag}) ${s.name} â€” ${dice}d6${s.defensive?" [DEF]" : ""}`;
      }

      function setChoice(v){
        lu.bonusChoice = v;
        skillBlock.style.display = (v === "skill") ? "" : "none";
        updateSkillSummary();
        updateNextDisabled();
      }

      if(lu.bonusChoice){
        const r = radios.find(x => x.value === lu.bonusChoice);
        if(r) r.checked = true;
      }
      setChoice(lu.bonusChoice || "");

      radios.forEach(r => {
        r.addEventListener("change", ()=>{
          setChoice(r.value);
          rerender();
        });
      });

      addSkillBtn.addEventListener("click", ()=>{
        openSkillEditor(lu.bonusSkill ? { ...lu.bonusSkill } : null, (created)=>{
          lu.bonusSkill = created;
        }, rerender);
      });

      updateSkillSummary();
      return box;
    }

    function renderMilestone(){
      const box = document.createElement("div");
      box.className = "field span12";
      box.style.display = "flex";
      box.style.flexDirection = "column";
      box.style.gap = "12px";

      const blocks = [];

      if(needsFeat){
        const wrap = document.createElement("div");
        const skillNames = skillsForPick();

        const featOpts = [
          `<option value="">Selectâ€¦</option>`,
          ...FEAT_TEMPLATES.map(f => `<option value="${escapeHtml(f.id)}">${escapeHtml(f.name)}</option>`),
          `<option value="custom">Customâ€¦</option>`
        ].join("");

        const dl = `
          <datalist id="luFeatSkillList">
            ${skillNames.map(n => `<option value="${escapeHtml(n)}"></option>`).join("")}
          </datalist>
        `;

        wrap.innerHTML = `
          <div class="pill">Feat (Level ${toLevel})</div>
          <div style="height:8px;"></div>

          <div class="fields">
            <div class="field span12">
              <label>Choose a feat</label>
              <select id="luFeatPick">${featOpts}</select>
              <div class="pill" id="luFeatHint" style="margin-top:8px;">â€”</div>
            </div>
          </div>

          ${dl}

          <div id="luFeatFieldsWrap" class="fields" style="margin-top:10px; display:none;"></div>

          <div id="luFeatCustomWrap" style="margin-top:10px; display:none;">
            <div class="fields">
              <div class="field span12">
                <label>Custom feat name (required)</label>
                <input id="luFeatCustomName" type="text" enterkeyhint="done" autocomplete="off">
              </div>
              <div class="field span12">
                <label>Custom feat description (optional)</label>
                <input id="luFeatCustomDesc" type="text" enterkeyhint="done" autocomplete="off">
              </div>
            </div>
          </div>

          <div class="pill" id="luFeatPreview" style="margin-top:10px;">Preview: â€”</div>

          <div id="luLearnedBlock" style="margin-top:10px; display:none;">
            <div class="pill">Learned skills: <span id="luLearnedCount">0</span> / 3</div>
            <div style="height:8px;"></div>
            <div class="row">
              <button class="primary" id="luAddLearnedSkill" type="button">Add Learned Skill</button>
              <button id="luClearLearned" type="button">Clear</button>
            </div>
            <div class="list" id="luLearnedList" style="margin-top:10px;"></div>
          </div>
        `;

        const sel = wrap.querySelector("#luFeatPick");
        const hint = wrap.querySelector("#luFeatHint");
        const fieldsWrap = wrap.querySelector("#luFeatFieldsWrap");
        const customWrap = wrap.querySelector("#luFeatCustomWrap");
        const cName = wrap.querySelector("#luFeatCustomName");
        const cDesc = wrap.querySelector("#luFeatCustomDesc");
        const preview = wrap.querySelector("#luFeatPreview");

        const learnedBlock = wrap.querySelector("#luLearnedBlock");
        const learnedCount = wrap.querySelector("#luLearnedCount");
        const learnedList = wrap.querySelector("#luLearnedList");
        const addLearnedSkill = wrap.querySelector("#luAddLearnedSkill");
        const clearLearned = wrap.querySelector("#luClearLearned");

        function templateHintText(t){
          if(!t) return "â€”";
          if(!t.desc) return t.name + ": â€”";
          let out = t.desc;
          for(const f of (t.fields||[])){
            const re = new RegExp("\\{\\{"+f.key+"\\}\\}","g");
            out = out.replace(re, `[${f.label}]`);
          }
          return `${t.name}: ${out}`;
        }

        function redrawLearned(){
          learnedList.innerHTML = "";
          learnedCount.textContent = String(lu.milestone.learnedSkills.length);

          if(lu.milestone.learnedSkills.length === 0){
            const p = document.createElement("div");
            p.className = "pill";
            p.textContent = "No learned skills yet";
            learnedList.appendChild(p);
          } else {
            lu.milestone.learnedSkills.forEach((s, idx)=>{
              const row = document.createElement("div");
              row.className = "item";

              const left = document.createElement("div");
              left.className = "left";
              left.style.flex="1";
              left.style.minWidth="0";

              const tag = (s.tag === "N" ? "N" : "B");
              const dice = clamp(safeInt(s.dice,1), 1, 6);
              const def = !!s.defensive;

              const title = document.createElement("div");
              title.className = "name";
              title.textContent = `(${tag}) ${s.name || "Unnamed"} â€” ${dice}d6${def ? " [DEF]" : ""}`;
              left.appendChild(title);

              const btns = document.createElement("div");
              btns.className = "row";

              const bEdit = document.createElement("button");
              bEdit.textContent = "Edit";
              bEdit.addEventListener("click", ()=>{
                openSkillEditor({ ...s }, (updated)=>{
                  lu.milestone.learnedSkills[idx] = updated;
                }, rerender);
              });

              const bDel = document.createElement("button");
              bDel.className = "danger";
              bDel.textContent = "Remove";
              bDel.addEventListener("click", ()=>{
                lu.milestone.learnedSkills.splice(idx, 1);
                rerender();
              });

              btns.appendChild(bEdit);
              btns.appendChild(bDel);

              row.appendChild(left);
              row.appendChild(btns);
              learnedList.appendChild(row);
            });
          }
        }

        function buildFieldsForTemplate(t){
          fieldsWrap.innerHTML = "";
          if(!t || !(t.fields||[]).length){
            fieldsWrap.style.display = "none";
            return;
          }
          fieldsWrap.style.display = "";

          for(const f of t.fields){
            const d = document.createElement("div");
            d.className = "field span6";

            if(f.type === "choice"){
              const opts = (f.options || []).map(o => `<option value="${escapeHtml(o)}">${escapeHtml(o)}</option>`).join("");
              d.innerHTML = `
                <label>${escapeHtml(f.label)}</label>
                <select data-key="${escapeHtml(f.key)}">
                  <option value="">Selectâ€¦</option>
                  ${opts}
                </select>
              `;
              const s = d.querySelector("select");
              s.value = String(lu.milestone.featVars[f.key] ?? "");
              s.addEventListener("change", ()=>{
                lu.milestone.featVars[f.key] = s.value;
                updateFeatUI(false);
              });
            }else{
              const listAttr = (f.type === "skill") ? ` list="luFeatSkillList"` : "";
              d.innerHTML = `
                <label>${escapeHtml(f.label)}</label>
                <input data-key="${escapeHtml(f.key)}" type="text"${listAttr} enterkeyhint="done" autocomplete="off">
              `;
              const inp = d.querySelector("input");
              inp.value = String(lu.milestone.featVars[f.key] ?? "");
              inp.addEventListener("input", ()=>{
                lu.milestone.featVars[f.key] = inp.value;
                updateFeatUI(false);
              });
            }

            fieldsWrap.appendChild(d);
          }
        }

        function updateFeatUI(skipHintRebuild){
          const feat = syncFeatDerived();

          learnedBlock.style.display = feat.learned ? "" : "none";
          customWrap.style.display = (lu.milestone.featTemplateId === "custom") ? "" : "none";

          const line = setFeatLinePreview();
          preview.textContent = "Preview: " + (line || "â€”");

          updateNextDisabled();

          if(!skipHintRebuild){
            if(lu.milestone.featTemplateId === "custom"){
              hint.textContent = "Custom: type a name and optional description.";
            }else{
              const t = getFeatTemplate(lu.milestone.featTemplateId);
              hint.textContent = templateHintText(t);
            }
          }
        }

        sel.value = lu.milestone.featTemplateId || "";
        cName.value = lu.milestone.customFeatName || "";
        cDesc.value = lu.milestone.customFeatDesc || "";

        sel.addEventListener("change", ()=>{
          lu.milestone.featTemplateId = sel.value || "";
          if(!lu.milestone.featVars || typeof lu.milestone.featVars !== "object") lu.milestone.featVars = {};
          rerender();
        });

        cName.addEventListener("input", ()=>{
          lu.milestone.customFeatName = cName.value || "";
          updateFeatUI(true);
        });
        cDesc.addEventListener("input", ()=>{
          lu.milestone.customFeatDesc = cDesc.value || "";
          updateFeatUI(true);
        });

        addLearnedSkill.addEventListener("click", ()=>{
          if(lu.milestone.learnedSkills.length >= 3){
            toast("Learned needs exactly 3 skills");
            return;
          }
          openSkillEditor(null, (created)=>{
            lu.milestone.learnedSkills.push(created);
          }, rerender);
        });

        clearLearned.addEventListener("click", ()=>{
          lu.milestone.learnedSkills = [];
          rerender();
        });

        if(lu.milestone.featTemplateId && lu.milestone.featTemplateId !== "custom"){
          const t = getFeatTemplate(lu.milestone.featTemplateId);
          buildFieldsForTemplate(t);
          hint.textContent = templateHintText(t);
        }else if(lu.milestone.featTemplateId === "custom"){
          hint.textContent = "Custom: type a name and optional description.";
        }else{
          hint.textContent = "Select a feat template (or Custom).";
        }

        updateFeatUI(true);
        redrawLearned();

        blocks.push(wrap);
      }

      if(needsStat){
        const canBody = (data.body ?? 1) < 2;
        const canMind = (data.mind ?? 1) < 2;

        const wrap = document.createElement("div");
        wrap.innerHTML = `<div class="pill">Body / Mind +1 (Level 5)</div>`;

        const inner = document.createElement("div");
        inner.style.marginTop = "8px";
        inner.style.color = "var(--muted)";
        inner.style.lineHeight = "1.5";

        if(!canBody && !canMind){
          inner.innerHTML = `<div>Body and Mind are already at 2. No change needed.</div>`;
        }else{
          inner.innerHTML = `
            <div style="margin-bottom:8px;">Choose one:</div>
            <label style="display:flex; gap:8px; align-items:center; ${canBody ? "" : "opacity:.5;"}">
              <input type="radio" name="luStatPick" value="body" style="width:auto;" ${canBody ? "" : "disabled"}>
              Body +1 (current ${data.body ?? 1})
            </label>
            <label style="display:flex; gap:8px; align-items:center; margin-top:8px; ${canMind ? "" : "opacity:.5;"}">
              <input type="radio" name="luStatPick" value="mind" style="width:auto;" ${canMind ? "" : "disabled"}>
              Mind +1 (current ${data.mind ?? 1})
            </label>
          `;

          const radios = [...inner.querySelectorAll('input[name="luStatPick"]')];
          radios.forEach(r => {
            r.checked = (lu.milestone.statPick === r.value);
            r.addEventListener("change", ()=>{
              lu.milestone.statPick = r.value;
              rerender();
            });
          });
        }

        wrap.appendChild(inner);
        blocks.push(wrap);
      }

      if(needsThreatAssist){
        const wrap = document.createElement("div");
        wrap.style.color = "var(--muted)";
        wrap.style.lineHeight = "1.5";
        wrap.innerHTML = `
          <div class="pill">Level 6</div>
          <div style="margin-top:8px;">
            This character can now apply successes to additional nearby Threats for 1 Grit/Focus, instead of 2.
          </div>
        `;
        blocks.push(wrap);
      }

      if(needsMastery){
        const wrap = document.createElement("div");
        wrap.innerHTML = `
          <div class="pill">Mastery (Level 10)</div>
          <div style="height:8px;"></div>
          <div class="fields">
            <div class="field span12">
              <label>Choose a skill to master</label>
              <select id="luMasterySel"></select>
              <div class="pill" style="margin-top:8px;">Or type a custom name below</div>
              <input id="luMasteryCustom" type="text" enterkeyhint="done" autocomplete="off" style="margin-top:8px;">
              <div class="pill" id="luMasteryHint" style="margin-top:8px;">Chosen skill will be renamed to add â€œMastery+â€.</div>
            </div>
          </div>
        `;

        const sel = wrap.querySelector("#luMasterySel");
        const custom = wrap.querySelector("#luMasteryCustom");

        const names = skillsForPick();
        const opts = ['<option value="">Selectâ€¦</option>']
          .concat(names.map(n => `<option value="${escapeHtml(n)}">${escapeHtml(n)}</option>`))
          .join("");
        sel.innerHTML = opts;

        sel.value = names.includes(lu.milestone.masterySkill) ? lu.milestone.masterySkill : "";
        custom.value = (!sel.value && lu.milestone.masterySkill) ? lu.milestone.masterySkill : "";

        sel.addEventListener("change", ()=>{
          if(sel.value){
            lu.milestone.masterySkill = sel.value;
            custom.value = "";
          }else{
            lu.milestone.masterySkill = (custom.value||"").trim();
          }
          updateNextDisabled();
        });

        custom.addEventListener("input", ()=>{
          const v = (custom.value||"").trim();
          if(v){
            sel.value = "";
            lu.milestone.masterySkill = v;
          }else{
            lu.milestone.masterySkill = sel.value || "";
          }
          updateNextDisabled();
        });

        blocks.push(wrap);
      }

      blocks.forEach(b => box.appendChild(b));
      return box;
    }

    function renderDice(){
      const box = document.createElement("div");
      box.className = "field span12";
      box.style.color = "var(--muted)";
      box.style.lineHeight = "1.5";

      const suggested = toLevel - 1;
      const current = safeInt(data.dp_max, 0);
      const applied = Math.max(current, suggested);

      box.innerHTML = `
        <div class="pill">Recommended Strive Dice max</div>
        <div style="margin-top:8px;">
          Rule suggests <b style="color:var(--text)">${suggested}</b> at Level ${toLevel} (Level âˆ’ 1).
        </div>
        <div style="margin-top:8px;">
          Current: <b style="color:var(--text)">${current}</b> â†’ will set to: <b style="color:var(--text)">${applied}</b>.
        </div>
      `;
      return box;
    }

    function renderSummary(){
      const box = document.createElement("div");
      box.className = "field span12";
      box.style.color = "var(--muted)";
      box.style.lineHeight = "1.55";

      const old = {
        level: data.level,
        grit_max: data.grit_max,
        focus_max: data.focus_max,
        dp_max: data.dp_max,
        body: data.body,
        mind: data.mind,
        grit_cur: data.grit_cur,
        focus_cur: data.focus_cur,
        dp_cur: data.dp_cur
      };

      const dG = lu.allocG + (lu.bonusChoice === "grit" ? 2 : 0);
      const dF = lu.allocF + (lu.bonusChoice === "focus" ? 2 : 0);

      const newG = old.grit_max + dG;
      const newF = old.focus_max + dF;

      const suggestedDP = toLevel - 1;
      const newDP = Math.max(old.dp_max, suggestedDP);
      const dDP = newDP - old.dp_max;

      let newBody = old.body;
      let newMind = old.mind;
      if(needsStat){
        if(lu.milestone.statPick === "body" && newBody < 2) newBody++;
        if(lu.milestone.statPick === "mind" && newMind < 2) newMind++;
      }

      const newSkills = gatherAllNewSkills();
      const featLine = needsFeat ? setFeatLinePreview() : "";
      const mRaw = (lu.milestone.masterySkill||"").trim();
      const mFinal = mRaw ? (mRaw.replace(/\s*Mastery\+\s*$/i,"").trim() + " Mastery+") : "";
      const masteryLine = needsMastery && mRaw ? `â€¢ [L10] Mastery: ${mFinal}` : "";

      const warn = alreadyApplied
        ? `<div class="pill" style="border-color: rgba(255,92,92,.55); color: var(--text); background: rgba(255,92,92,.10); margin-top:10px;">
             Warning: applying Level ${toLevel} again will stack benefits.
           </div>`
        : "";

      const skillLines = (newSkills.length === 0)
        ? "â€¢ â€”"
        : newSkills.map(s => {
            const tag = (s.tag === "N" ? "N" : "B");
            const dice = clamp(safeInt(s.dice,1), 1, 6);
            const def = !!s.defensive;
            return `â€¢ (${tag}) ${s.name} â€” ${dice}d6${def ? " [DEF]" : ""}`;
          }).join("\n");

      const featBlock = needsFeat ? (featLine ? featLine : "â€¢ â€”") : "â€”";
      const masteryBlock = needsMastery ? (masteryLine ? masteryLine : "â€¢ â€”") : "â€”";

      box.innerHTML = `
        <div class="pill">Changes</div>
        <div style="margin-top:8px;">
          <div><b style="color:var(--text)">Level</b>: ${old.level} â†’ ${toLevel}</div>
          <div><b style="color:var(--text)">Grit max</b>: ${old.grit_max} â†’ ${newG}</div>
          <div><b style="color:var(--text)">Focus max</b>: ${old.focus_max} â†’ ${newF}</div>
          <div><b style="color:var(--text)">Strive Dice max</b>: ${old.dp_max} â†’ ${newDP}</div>
          <div><b style="color:var(--text)">Body / Mind</b>: ${old.body} / ${old.mind} â†’ ${newBody} / ${newMind}</div>
        </div>

        <div style="height:10px;"></div>
        <div class="pill">Rest refresh (current pools)</div>
        <div style="margin-top:8px;">
          <div><b style="color:var(--text)">Grit current</b>: ${old.grit_cur} â†’ ${old.grit_cur + dG}</div>
          <div><b style="color:var(--text)">Focus current</b>: ${old.focus_cur} â†’ ${old.focus_cur + dF}</div>
          <div><b style="color:var(--text)">Strive Dice current</b>: ${old.dp_cur} â†’ ${old.dp_cur + dDP}</div>
        </div>

        <div style="height:10px;"></div>
        <div class="pill">New skills</div>
        <pre style="white-space:pre-wrap; margin:8px 0 0; color:var(--muted); font: 700 13px var(--mono);">${escapeHtml(skillLines)}</pre>

        <div style="height:10px;"></div>
        <div class="pill">Feat</div>
        <pre style="white-space:pre-wrap; margin:8px 0 0; color:var(--muted); font: 700 13px var(--mono);">${escapeHtml(featBlock)}</pre>

        <div style="height:10px;"></div>
        <div class="pill">Mastery</div>
        <pre style="white-space:pre-wrap; margin:8px 0 0; color:var(--muted); font: 700 13px var(--mono);">${escapeHtml(masteryBlock)}</pre>

        ${warn}
      `;
      return box;
    }

    function appendFeatureLine(line){
      const ln = (line || "").trim();
      if(!ln) return;
      const pref = ln.startsWith("â€¢") ? ln : `â€¢ ${ln}`;
      const cur = (data.features_text || "").trim();
      data.features_text = cur ? (cur + "\n" + pref) : pref;
    }

    function featuresHasLine(line){
      const tgt = String(line||"").trim();
      if(!tgt) return false;

      const bare = tgt.replace(/^â€¢\s*/,"").trim();
      const lines = String(data.features_text||"")
        .split(/\r?\n/)
        .map(l=>l.trim())
        .filter(Boolean);

      return lines.includes(tgt) || lines.includes("â€¢ " + bare) || lines.includes(bare);
    }

    function applyLevelUp(){
      // PATCH: level-ups happen during a rest, so increase CURRENT pools by same deltas as max increases.
      const oldGMax = safeInt(data.grit_max,0);
      const oldFMax = safeInt(data.focus_max,0);
      const oldDPMax = safeInt(data.dp_max,0);

      const dG = lu.allocG + (lu.bonusChoice === "grit" ? 2 : 0);
      const dF = lu.allocF + (lu.bonusChoice === "focus" ? 2 : 0);

      data.level = toLevel;

      data.grit_max = oldGMax + dG;
      data.focus_max = oldFMax + dF;

      data.grit_cur = safeInt(data.grit_cur,0) + dG;
      data.focus_cur = safeInt(data.focus_cur,0) + dF;

      if(lu.bonusChoice === "skill" && lu.bonusSkill){
        data.skills = Array.isArray(data.skills) ? data.skills : [];
        data.skills.push(lu.bonusSkill);
      }

      if(needsFeat){
        const featLine = setFeatLinePreview();
        if(featLine) appendFeatureLine(featLine);

        if(lu.milestone.learned){
          data.skills = Array.isArray(data.skills) ? data.skills : [];
          for(const s of (lu.milestone.learnedSkills || [])){
            data.skills.push(s);
          }
        }
      }

      if(needsStat){
        if(lu.milestone.statPick === "body" && (data.body ?? 1) < 2) data.body = (data.body ?? 1) + 1;
        if(lu.milestone.statPick === "mind" && (data.mind ?? 1) < 2) data.mind = (data.mind ?? 1) + 1;
      }

      if(needsThreatAssist){
        if(data.threat_assist_cost === null || typeof data.threat_assist_cost === "undefined"){
          data.threat_assist_cost = 1;
        }

        const l6Line = "â€¢ This character can apply its successes to additional nearby Threats for 1 Grit/Focus.";
        if(!featuresHasLine(l6Line)){
          appendFeatureLine(l6Line);
        }
      }

      // Strive dice max: recommended = level - 1, never decrease
      const suggested = toLevel - 1;
      data.dp_max = Math.max(oldDPMax, suggested);
      const dDP = data.dp_max - oldDPMax;
      data.dp_cur = safeInt(data.dp_cur,0) + dDP;

      // Level 10 mastery: rename chosen skill by appending " Mastery+"
      if(needsMastery){
        const raw = (lu.milestone.masterySkill || "").trim();
        if(raw){
          const base = raw.replace(/\s*Mastery\+\s*$/i, "").trim();
          const finalName = base + " Mastery+";

          data.mastery_skill = finalName;

          const skills = Array.isArray(data.skills) ? data.skills : [];
          let idx = skills.findIndex(s => String(s?.name||"").trim() === raw);
          if(idx < 0) idx = skills.findIndex(s => String(s?.name||"").trim() === base);
          if(idx < 0) idx = skills.findIndex(s => String(s?.name||"").trim() === finalName);
          if(idx >= 0){
            const curName = String(skills[idx].name||"").trim();
            const curBase = curName.replace(/\s*Mastery\+\s*$/i, "").trim();
            skills[idx].name = curBase + " Mastery+";
          }

          appendFeatureLine(`â€¢ [L10] Mastery: ${finalName}`);
        }
      }

      // Clamp currents safely (should already be <= new max, but keep robust)
      data.grit_cur = clamp(safeInt(data.grit_cur,0), 0, data.grit_max);
      data.focus_cur = clamp(safeInt(data.focus_cur,0), 0, data.focus_max);
      data.dp_cur = clamp(safeInt(data.dp_cur,0), 0, data.dp_max);

      if(!data.advancement_log || typeof data.advancement_log !== "object") data.advancement_log = { applied_levels: [] };
      if(!Array.isArray(data.advancement_log.applied_levels)) data.advancement_log.applied_levels = [];
      if(!data.advancement_log.applied_levels.includes(toLevel)) data.advancement_log.applied_levels.push(toLevel);

      normaliseDerived();
      syncInputsFromData();
      refreshAll();
      saveAutosave();
      closeModal();
      toast("Level up applied");
    }

    function escapeHtml(s){
      return String(s||"")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    rerender();
  }

  function escapeHtml(s){
    return String(s||"")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  // --- Portrait rendering + interactions
  const canvas = $("portraitCanvas");
  const ctx = canvas.getContext("2d");
  let portraitImg = null;

  function updatePortraitLockUI(){
    const b = $("btnPortraitLock");
    if(data.portrait.locked){
      b.textContent = "ðŸ”’";
      b.classList.remove("is-unlocked");
      b.title = "Locked (prevents drag + wheel/pinch zoom)";
    }else{
      b.textContent = "ðŸ”“";
      b.classList.add("is-unlocked");
      b.title = "Unlocked (drag/pinch/wheel enabled)";
    }
  }

  function refreshPortraitUI(){
    $("portraitZoom").value = String(data.portrait.zoom.toFixed(2));
    $("zoomPill").textContent = `${data.portrait.zoom.toFixed(2)}Ã—`;
    updatePortraitLockUI();
  }

  function loadPortraitFromDataUrl(url){
    if(!url){ portraitImg = null; renderPortrait(); return; }
    const img = new Image();
    img.onload = () => { portraitImg = img; renderPortrait(); };
    img.src = url;
  }

  function onPortraitFile(){
    const f = $("portraitFile").files?.[0];
    $("portraitFile").value = "";
    if(!f) return;
    const reader = new FileReader();
    reader.onload = () => {
      data.portrait.dataUrl = String(reader.result || "");
      data.portrait.zoom = 1.0;
      data.portrait.offX = 0;
      data.portrait.offY = 0;
      loadPortraitFromDataUrl(data.portrait.dataUrl);
      refreshPortraitUI();
      saveAutosave();
    };
    reader.readAsDataURL(f);
  }

  function setPortraitZoom(z){
    data.portrait.zoom = clamp(z, 0.5, 3.0);
    refreshPortraitUI();
    renderPortrait();
    saveAutosave();
  }

  function drawCoverImage(targetCtx, w, h, img, zoom, offX, offY){
    targetCtx.clearRect(0,0,w,h);
    targetCtx.fillStyle = "rgba(0,0,0,0.18)";
    targetCtx.fillRect(0,0,w,h);

    if(!img){
      targetCtx.fillStyle = "rgba(255,255,255,0.18)";
      targetCtx.font = `16px ${getComputedStyle(document.documentElement).getPropertyValue("--sans")}`;
      targetCtx.textAlign = "center";
      targetCtx.textBaseline = "middle";
      targetCtx.fillText("No image", w/2, h/2);
      return;
    }

    const iw = img.naturalWidth || img.width;
    const ih = img.naturalHeight || img.height;
    const scale = Math.max(w/iw, h/ih) * zoom;
    const dw = iw * scale;
    const dh = ih * scale;

    const cx = (w - dw)/2 + offX;
    const cy = (h - dh)/2 + offY;

    targetCtx.imageSmoothingEnabled = true;
    targetCtx.imageSmoothingQuality = "high";
    targetCtx.drawImage(img, cx, cy, dw, dh);
  }

  function renderPortrait(){
    normaliseDerived();
    drawCoverImage(ctx, canvas.width, canvas.height, portraitImg, data.portrait.zoom, data.portrait.offX, data.portrait.offY);

    ctx.strokeStyle = "rgba(255,255,255,0.16)";
    ctx.lineWidth = 2;
    ctx.strokeRect(1,1,canvas.width-2,canvas.height-2);

    // Token positioning guide circle (30% opacity, preview only)
    // Circle spans from 13.5% to 55% of height, centered horizontally
    const guideRadius = canvas.height * 0.2075;  // (55% - 13.5%) / 2
    const guideCenterX = canvas.width / 2;
    const guideCenterY = canvas.height * 0.3425; // 13.5% + 20.75%
    ctx.save();
    ctx.beginPath();
    ctx.arc(guideCenterX, guideCenterY, guideRadius, 0, Math.PI * 2);
    ctx.strokeStyle = "rgba(255,255,255,0.30)";
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.restore();

    // Front card preview: stat circles and name box
    const W = canvas.width, H = canvas.height;
    const refW = 1000, refH = 1400;
    const sx = W / refW;
    const sy = H / refH;
    const s = Math.min(sx, sy);
    const circleAlpha = 0.55;

    // Stat circles
    const cx = 140 * sx;
    const cy = 140 * sy;
    const r = 90 * s;
    drawCircleStat(ctx, cx, cy, r, data.grit_max ?? 0, `rgba(255,0,0,${circleAlpha})`);
    drawCircleStat(ctx, W - cx, cy, r, data.focus_max ?? 0, `rgba(0,0,255,${circleAlpha})`);

    // Name box at TOP, between circles
    const gap = 16 * s;  // ~15px gap
    const nameH = 140 * s;  // ~130px height
    const nameX = cx + r + gap;
    const nameY = cy - (nameH / 2);
    const nameW = W - (2 * nameX);
    const nameText = (data.name || "").trim() || "â€”";
    const baseFontSize = Math.round(64 * 1.3 * s);
    const { fontSize: nameFont, letterSpacing } = getAdaptiveTextStyle(nameText, baseFontSize);
    drawTextBox(ctx, nameX, nameY, nameW, nameH, nameText, nameFont, "center", letterSpacing);
  }

  function blurActiveInput(){
    const ae = document.activeElement;
    if(ae && (ae.tagName === "INPUT" || ae.tagName === "TEXTAREA" || ae.tagName === "SELECT")){
      ae.blur();
    }
  }

  const pointers = new Map();
  let pinchStartDist = 0;
  let pinchStartZoom = 1;
  let pinchStartOffX = 0;
  let pinchStartOffY = 0;
  let pinchMid = {x:0,y:0};

  function canvasPoint(e){
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);
    return {x,y};
  }

  canvas.addEventListener("pointerdown", (e)=>{
    blurActiveInput();
    canvas.setPointerCapture(e.pointerId);

    if(data.portrait.locked) return;

    const pt = canvasPoint(e);
    pointers.set(e.pointerId, pt);

    if(pointers.size === 1){
      dragStart = { x: pt.x, y: pt.y, ox: data.portrait.offX, oy: data.portrait.offY };
    }else if(pointers.size === 2){
      const pts = [...pointers.values()];
      pinchStartDist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
      pinchStartZoom = data.portrait.zoom;
      pinchStartOffX = data.portrait.offX;
      pinchStartOffY = data.portrait.offY;
      pinchMid = { x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2 };
    }
  });

  let dragStart = null;

  canvas.addEventListener("pointermove", (e)=>{
    if(data.portrait.locked) return;
    if(!pointers.has(e.pointerId)) return;

    const pt = canvasPoint(e);
    pointers.set(e.pointerId, pt);

    if(pointers.size === 1 && dragStart){
      data.portrait.offX = dragStart.ox + (pt.x - dragStart.x);
      data.portrait.offY = dragStart.oy + (pt.y - dragStart.y);
      renderPortrait();
      return;
    }

    if(pointers.size === 2){
      const pts = [...pointers.values()];
      const dist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
      if(pinchStartDist <= 0) return;

      const ratio = dist / pinchStartDist;
      const newZoom = clamp(pinchStartZoom * ratio, 0.5, 3.0);

      const scale = newZoom / pinchStartZoom;
      data.portrait.zoom = newZoom;
      data.portrait.offX = pinchStartOffX + (1 - scale) * (pinchMid.x - canvas.width/2);
      data.portrait.offY = pinchStartOffY + (1 - scale) * (pinchMid.y - canvas.height/2);

      refreshPortraitUI();
      renderPortrait();
    }
  });

  canvas.addEventListener("pointerup", (e)=>{
    pointers.delete(e.pointerId);
    if(pointers.size < 2){
      pinchStartDist = 0;
    }
    if(pointers.size === 0){
      dragStart = null;
      saveAutosave();
    }
  });
  canvas.addEventListener("pointercancel", (e)=>{
    pointers.delete(e.pointerId);
    dragStart = null;
    pinchStartDist = 0;
    saveAutosave();
  });

  canvas.addEventListener("wheel", (e)=>{
    if(data.portrait.locked) return;
    e.preventDefault();
    const delta = (e.deltaY > 0) ? -0.06 : 0.06;
    setPortraitZoom(data.portrait.zoom + delta);
  }, {passive:false});

  // --- Card export helpers
  function roundRectPath(c, x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    c.beginPath();
    c.moveTo(x+rr, y);
    c.arcTo(x+w, y, x+w, y+h, rr);
    c.arcTo(x+w, y+h, x, y+h, rr);
    c.arcTo(x, y+h, x, y, rr);
    c.arcTo(x, y, x+w, y, rr);
    c.closePath();
  }

  function drawCardBase(c, W, H, { pImg, pCanvas, pData }){
    const refW = 1000, refH = 1400;
    const sx = W / refW;
    const sy = H / refH;
    const s  = Math.min(sx, sy);

    c.clearRect(0,0,W,H);
    c.save();

    // Border thickness (keeps your "doubled" intent)
    const borderW = 30 * s;

    // IMPORTANT: corner radius MUST be > borderW (otherwise inner cutout becomes square)
    const cornerR = Math.max(46 * s, borderW + (18 * s));
    const maskCornerR = cornerR + (1 * s); // slightly rounder mask so no pixels peek outside

    // Clip to rounded rect so outer corners are transparent in PNG
    roundRectPath(c, 0,0,W,H, maskCornerR);
    c.clip();

    // Background: portrait cover-cropped (using live portrait zoom/offset)
    if(pImg){
      const imgSx = W / pCanvas.width;
      const imgSy = H / pCanvas.height;

      drawCoverImage(
        c, W, H,
        pImg,
        pData.portrait.zoom,
        pData.portrait.offX * imgSx,
        pData.portrait.offY * imgSy
      );
    }else{
      c.fillStyle = "rgba(0,0,0,0.25)";
      c.fillRect(0,0,W,H);
    }

    // Dark wash overlay
    c.fillStyle = "rgba(0,0,0,0.18)";
    c.fillRect(0,0,W,H);

    c.restore();

    // Border ring: outer minus inner using even-odd fill (drawn INSIDE)
    const inset = Math.min(borderW, (Math.min(W,H) / 2) - 1);
    const innerR = Math.max(1, cornerR - inset);

    function addRoundRectSubpath(ctx2, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx2.moveTo(x + rr, y);
      ctx2.arcTo(x + w, y,     x + w, y + h, rr);
      ctx2.arcTo(x + w, y + h, x,     y + h, rr);
      ctx2.arcTo(x,     y + h, x,     y,     rr);
      ctx2.arcTo(x,     y,     x + w, y,     rr);
      ctx2.closePath();
    }

    c.save();
    c.beginPath();
    addRoundRectSubpath(c, 0, 0, W, H, cornerR);
    addRoundRectSubpath(c, inset, inset, W - inset*2, H - inset*2, innerR);
    c.fillStyle = "rgba(0,0,0,0.95)";
    c.fill("evenodd");
    c.restore();

    // Thin highlight stroke (inset)
    c.save();
    const hiInset = inset * 0.5;
    const hiR = Math.max(1, cornerR - hiInset);
    roundRectPath(c, hiInset, hiInset, W - hiInset*2, H - hiInset*2, hiR);
    c.strokeStyle = "rgba(255,255,255,0.20)";
    c.lineWidth = Math.max(1, 4 * s);
    c.stroke();
    c.restore();
  }

  function drawCircleStat(c, cx, cy, r, text, fillColor){
    c.save();
    c.beginPath();
    c.arc(cx, cy, r, 0, Math.PI*2);
    c.fillStyle = fillColor || "rgb(255,255,255)";
    c.fill();
    c.lineWidth = 8;
    c.strokeStyle = "rgba(255,255,255,0.70)";
    c.stroke();

    c.fillStyle = "rgba(255,255,255,0.95)";
    c.strokeStyle = "rgba(0,0,0,0.75)";
    c.lineWidth = 6;
    c.font = `900 ${Math.round(r*0.95)}px ${FONT_SERIF}`;
    c.textAlign = "center";
    c.textBaseline = "middle";
    const t = String(text ?? "");
    c.strokeText(t, cx, cy+2);
    c.fillText(t, cx, cy+2);
    c.restore();
  }

  function drawTextBox(c, x,y,w,h, text, fontPx, align="center", letterSpacing=0){
    c.save();
    roundRectPath(c, x,y,w,h, 34);
    c.fillStyle = "rgba(0,0,0,0.55)";
    c.fill();
    c.lineWidth = 6;
    c.strokeStyle = "rgba(255,255,255,0.60)";
    c.stroke();

    c.beginPath();
    roundRectPath(c, x,y,w,h, 34);
    c.clip();

    c.fillStyle = "rgba(255,255,255,0.95)";
    c.strokeStyle = "rgba(0,0,0,0.75)";
    c.lineWidth = 6;
    c.font = `900 ${fontPx}px ${FONT_SERIF}`;
    c.textAlign = align;
    c.textBaseline = "middle";

    // Apply letter spacing if supported
    if (letterSpacing !== 0 && typeof c.letterSpacing !== 'undefined') {
      c.letterSpacing = `${letterSpacing}px`;
    }

    const tx = x + (align==="center" ? w/2 : 18);
    const ty = y + h/2;

    c.strokeText(text, tx, ty);
    c.fillText(text, tx, ty);
    c.restore();
  }

  function wrapText(c, text, x, y, maxWidth, lineHeight, maxLines){
    const words = text.split(/\s+/);
    let line = "";
    let lineCount = 0;
    for(let i=0;i<words.length;i++){
      const test = line ? (line + " " + words[i]) : words[i];
      if(c.measureText(test).width > maxWidth && line){
        c.fillText(line, x, y + lineCount*lineHeight);
        line = words[i];
        lineCount++;
        if(maxLines && lineCount >= maxLines) return lineCount;
      }else{
        line = test;
      }
    }
    if(line && (!maxLines || lineCount < maxLines)){
      c.fillText(line, x, y + lineCount*lineHeight);
      lineCount++;
    }
    return lineCount;
  }

  function drawBackTextBox(c, x, y, w, h, theData, scale=1){
    c.save();
    roundRectPath(c, x,y,w,h, 34);
    c.fillStyle = "rgba(0,0,0,0.55)";
    c.fill();
    c.lineWidth = 6;
    c.strokeStyle = "rgba(255,255,255,0.60)";
    c.stroke();

    c.beginPath();
    roundRectPath(c, x,y,w,h, 34);
    c.clip();

    const pad = 26 * scale;
    const tx = x + pad;
    let ty = y + pad;
    const tw = w - pad*2;

    const skills = (theData.skills || []).map(s => `â€¢ ${s.name || "Unnamed"}`).join("\n") || "â€¢ â€”";
    const feats  = (theData.features_text || "")
      .split(/\r?\n/).map(l=>l.trim()).filter(Boolean)
      .map(l=>l.startsWith("â€¢") ? l : `â€¢ ${l}`).join("\n") || "â€¢ â€”";

    const block = `Skills:\n${skills}\n\nFeatures:\n${feats}`;

    c.fillStyle = "rgba(255,255,255,0.95)";
    c.font = `800 ${Math.round(34 * scale)}px ${FONT_SERIF}`;
    c.textAlign = "left";
    c.textBaseline = "top";

    const lines = block.split("\n");
    const lh = 44 * scale;

    for(const ln of lines){
      if(!ln.trim()){
        ty += lh * 0.6;
        continue;
      }
      const remainingLines = Math.floor((y + h - ty - pad) / lh);
      const used = wrapText(c, ln, tx, ty, tw, lh, remainingLines);
      ty += lh * used;
      if(ty > y + h - pad) break;
    }

    c.restore();
  }

  function downloadPng(cnv, filename){
    const a = document.createElement("a");
    a.href = cnv.toDataURL("image/png");
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  function exportCardPNGs(){
    const name = safeFileName(data.name);

    // Guardrail: force-lock portrait while exporting (prevents mid-gesture drift)
    const prevLocked = data.portrait.locked;
    data.portrait.locked = true;
    updatePortraitLockUI();
    pointers.clear();
    dragStart = null;
    pinchStartDist = 0;

    const W = EXPORT_CARD_W, H = EXPORT_CARD_H;

    const refW = 1000, refH = 1400;
    const sx = W / refW;
    const sy = H / refH;
    const s  = Math.min(sx, sy);

    const circleAlpha = 0.55; // match text box opacity

    const portraitCanvas = $("portraitCanvas");

    // ---------- FRONT ----------
    const front = document.createElement("canvas");
    front.width = W; front.height = H;
    const cf = front.getContext("2d");

    drawCardBase(cf, W, H, { pImg: portraitImg, pCanvas: portraitCanvas, pData: data });

    // Circles: red left, blue right (alpha matches text boxes)
    const cx = 140 * sx;
    const cy = 140 * sy;
    const r  = 90  * s;
    drawCircleStat(cf, cx,     cy, r, data.grit_max  ?? 0, `rgba(255,0,0,${circleAlpha})`);
    drawCircleStat(cf, W - cx, cy, r, data.focus_max ?? 0, `rgba(0,0,255,${circleAlpha})`);

    // Name box at TOP, between circles (font +30% base, with adaptive sizing)
    const gap = 16 * s;  // ~15px gap between circles and name box
    const nameH = 140 * s;  // ~130px height
    const nameX = cx + r + gap;  // After left circle + gap
    const nameY = cy - (nameH / 2);  // Vertically centered with circles
    const nameW = W - (2 * nameX);  // Symmetric width between circles
    const nameText = (data.name || "").trim() || "â€”";
    const baseFontSize = Math.round(64 * 1.3 * s);
    const { fontSize: nameFont, letterSpacing } = getAdaptiveTextStyle(nameText, baseFontSize);
    drawTextBox(cf, nameX, nameY, nameW, nameH, nameText, nameFont, "center", letterSpacing);

    downloadPng(front, `${name}_F.png`);

    // ---------- BACK ----------
    const back = document.createElement("canvas");
    back.width = W; back.height = H;
    const cb = back.getContext("2d");

    drawCardBase(cb, W, H, { pImg: portraitImg, pCanvas: portraitCanvas, pData: data });

    // show Xd6 / Yd6 on Card B
    drawCircleStat(cb, cx,     cy, r, `${data.body ?? 1}d6`, `rgba(255,0,0,${circleAlpha})`);
    drawCircleStat(cb, W - cx, cy, r, `${data.mind ?? 1}d6`, `rgba(0,0,255,${circleAlpha})`);

    // Strive dice max circle (black, centered at top)
    drawCircleStat(cb, W / 2, cy, r, data.dp_max ?? 0, `rgba(0,0,0,${circleAlpha})`);

    const backX = 80 * sx;
    const backY = 320 * sy;
    const backW = W - (160 * sx);
    const backH = H - (400 * sy);
    drawBackTextBox(cb, backX, backY, backW, backH, data, s);

    downloadPng(back, `${name}_B.png`);

    // Restore lock state
    data.portrait.locked = prevLocked;
    updatePortraitLockUI();
    toast("Exported card PNGs");
  }

  // --- Init
  loadAutosave();
  normaliseDerived();
  bindInputs();
  syncInputsFromData();
  refreshAll();
  loadPortraitFromDataUrl(data.portrait.dataUrl);
  renderPortrait();
  setTab("character");
  saveAutosave();
})();
</script>
</body>
</html>
